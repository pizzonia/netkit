===============================================================================

This patch turns the standard iproute implementation into one that supports the
MPLS framework implemented by James Leu, Ramon Casellas, and David S. Miller.

TECHNICAL INFORMATION:

iproute2-mpls-1.1 version iproute2-ss070710, checked out from the MPLS project's
P4 repository on Oct 25th, 2008.

Applies to iproute2-2.6.22-070710, available from:
http://devresources.linux-foundation.org/dev/iproute2/download/iproute2-2.6.22-070710.tar.gz

This patch has been obtained using the following procedure:
 1) First of all, Redhat-specific files have been removed from the package.
 2) Then, the following files have been copied from a 2.6.26.5 Linux kernel
 tree, patched with MPLS Linux 1.962, to the include/linux directory of the
 package:
    genetlink.h
    if_ether.h
    mpls.h
    rtnetlink.h
    shim.h
    if_link.h
    if_addr.h
    neighbour.h
    socket.h
 3) The file include/linux/rtnetlink.h has been slightly modified to include
 RTA_FWMASK back.
 4) The resulting package has been diff'ed against a clean
 iproute2-2.6.22-070710.

===============================================================================

diff -Naur iproute2-2.6.22-070710/include/bits/socket.h iproute2-mpls-1.1/include/bits/socket.h
--- iproute2-2.6.22-070710/include/bits/socket.h	1970-01-01 01:00:00.000000000 +0100
+++ iproute2-mpls-1.1/include/bits/socket.h	2008-10-07 14:40:29.000000000 +0200
@@ -0,0 +1,332 @@
+/* System-specific socket constants and types.  Linux version.
+   Copyright (C) 1991, 1992, 1994-2001, 2004, 2006, 2007
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#ifndef __BITS_SOCKET_H
+#define __BITS_SOCKET_H
+
+#ifndef _SYS_SOCKET_H
+# error "Never include <bits/socket.h> directly; use <sys/socket.h> instead."
+#endif
+
+#define	__need_size_t
+#define __need_NULL
+#include <stddef.h>
+
+#include <limits.h>
+#include <sys/types.h>
+
+/* Type for length arguments in socket calls.  */
+#ifndef __socklen_t_defined
+typedef __socklen_t socklen_t;
+# define __socklen_t_defined
+#endif
+
+/* Types of sockets.  */
+enum __socket_type
+{
+  SOCK_STREAM = 1,		/* Sequenced, reliable, connection-based
+				   byte streams.  */
+#define SOCK_STREAM SOCK_STREAM
+  SOCK_DGRAM = 2,		/* Connectionless, unreliable datagrams
+				   of fixed maximum length.  */
+#define SOCK_DGRAM SOCK_DGRAM
+  SOCK_RAW = 3,			/* Raw protocol interface.  */
+#define SOCK_RAW SOCK_RAW
+  SOCK_RDM = 4,			/* Reliably-delivered messages.  */
+#define SOCK_RDM SOCK_RDM
+  SOCK_SEQPACKET = 5,		/* Sequenced, reliable, connection-based,
+				   datagrams of fixed maximum length.  */
+#define SOCK_SEQPACKET SOCK_SEQPACKET
+  SOCK_PACKET = 10		/* Linux specific way of getting packets
+				   at the dev level.  For writing rarp and
+				   other similar things on the user level. */
+#define SOCK_PACKET SOCK_PACKET
+};
+
+/* Protocol families.  */
+#define	PF_UNSPEC	0	/* Unspecified.  */
+#define	PF_LOCAL	1	/* Local to host (pipes and file-domain).  */
+#define	PF_UNIX		PF_LOCAL /* POSIX name for PF_LOCAL.  */
+#define	PF_FILE		PF_LOCAL /* Another non-standard name for PF_LOCAL.  */
+#define	PF_INET		2	/* IP protocol family.  */
+#define	PF_AX25		3	/* Amateur Radio AX.25.  */
+#define	PF_IPX		4	/* Novell Internet Protocol.  */
+#define	PF_APPLETALK	5	/* Appletalk DDP.  */
+#define	PF_NETROM	6	/* Amateur radio NetROM.  */
+#define	PF_BRIDGE	7	/* Multiprotocol bridge.  */
+#define	PF_ATMPVC	8	/* ATM PVCs.  */
+#define	PF_X25		9	/* Reserved for X.25 project.  */
+#define	PF_INET6	10	/* IP version 6.  */
+#define	PF_ROSE		11	/* Amateur Radio X.25 PLP.  */
+#define	PF_DECnet	12	/* Reserved for DECnet project.  */
+#define	PF_NETBEUI	13	/* Reserved for 802.2LLC project.  */
+#define	PF_SECURITY	14	/* Security callback pseudo AF.  */
+#define	PF_KEY		15	/* PF_KEY key management API.  */
+#define	PF_NETLINK	16
+#define	PF_ROUTE	PF_NETLINK /* Alias to emulate 4.4BSD.  */
+#define	PF_PACKET	17	/* Packet family.  */
+#define	PF_ASH		18	/* Ash.  */
+#define	PF_ECONET	19	/* Acorn Econet.  */
+#define	PF_ATMSVC	20	/* ATM SVCs.  */
+#define	PF_SNA		22	/* Linux SNA Project */
+#define	PF_IRDA		23	/* IRDA sockets.  */
+#define	PF_PPPOX	24	/* PPPoX sockets.  */
+#define	PF_WANPIPE	25	/* Wanpipe API sockets.  */
+#define	PF_MPLS		28	/* MPLS sockets.  */
+#define	PF_BLUETOOTH	31	/* Bluetooth sockets.  */
+#define	PF_IUCV		32	/* IUCV sockets.  */
+#define PF_RXRPC	33	/* RxRPC sockets.  */
+#define	PF_MAX		34	/* For now..  */
+
+/* Address families.  */
+#define	AF_UNSPEC	PF_UNSPEC
+#define	AF_LOCAL	PF_LOCAL
+#define	AF_UNIX		PF_UNIX
+#define	AF_FILE		PF_FILE
+#define	AF_INET		PF_INET
+#define	AF_AX25		PF_AX25
+#define	AF_IPX		PF_IPX
+#define	AF_APPLETALK	PF_APPLETALK
+#define	AF_NETROM	PF_NETROM
+#define	AF_BRIDGE	PF_BRIDGE
+#define	AF_ATMPVC	PF_ATMPVC
+#define	AF_X25		PF_X25
+#define	AF_INET6	PF_INET6
+#define	AF_ROSE		PF_ROSE
+#define	AF_DECnet	PF_DECnet
+#define	AF_NETBEUI	PF_NETBEUI
+#define	AF_SECURITY	PF_SECURITY
+#define	AF_KEY		PF_KEY
+#define	AF_NETLINK	PF_NETLINK
+#define	AF_ROUTE	PF_ROUTE
+#define	AF_PACKET	PF_PACKET
+#define	AF_ASH		PF_ASH
+#define	AF_ECONET	PF_ECONET
+#define	AF_ATMSVC	PF_ATMSVC
+#define	AF_SNA		PF_SNA
+#define	AF_IRDA		PF_IRDA
+#define	AF_PPPOX	PF_PPPOX
+#define	AF_WANPIPE	PF_WANPIPE
+#define	AF_MPLS		PF_MPLS
+#define	AF_BLUETOOTH	PF_BLUETOOTH
+#define	AF_IUCV		PF_IUCV
+#define AF_RXRPC	PF_RXRPC
+#define	AF_MAX		PF_MAX
+
+/* Socket level values.  Others are defined in the appropriate headers.
+
+   XXX These definitions also should go into the appropriate headers as
+   far as they are available.  */
+#define SOL_RAW		255
+#define SOL_DECNET      261
+#define SOL_X25         262
+#define SOL_PACKET	263
+#define SOL_ATM		264	/* ATM layer (cell level).  */
+#define SOL_AAL		265	/* ATM Adaption Layer (packet level).  */
+#define SOL_IRDA	266
+
+/* Maximum queue length specifiable by listen.  */
+#define SOMAXCONN	128
+
+/* Get the definition of the macro to define the common sockaddr members.  */
+#include <bits/sockaddr.h>
+
+/* Structure describing a generic socket address.  */
+struct sockaddr
+  {
+    __SOCKADDR_COMMON (sa_);	/* Common data: address family and length.  */
+    char sa_data[14];		/* Address data.  */
+  };
+
+
+/* Structure large enough to hold any socket address (with the historical
+   exception of AF_UNIX).  We reserve 128 bytes.  */
+#if ULONG_MAX > 0xffffffff
+# define __ss_aligntype	__uint64_t
+#else
+# define __ss_aligntype	__uint32_t
+#endif
+#define _SS_SIZE	128
+#define _SS_PADSIZE	(_SS_SIZE - (2 * sizeof (__ss_aligntype)))
+
+struct sockaddr_storage
+  {
+    __SOCKADDR_COMMON (ss_);	/* Address family, etc.  */
+    __ss_aligntype __ss_align;	/* Force desired alignment.  */
+    char __ss_padding[_SS_PADSIZE];
+  };
+
+
+/* Bits in the FLAGS argument to `send', `recv', et al.  */
+enum
+  {
+    MSG_OOB		= 0x01,	/* Process out-of-band data.  */
+#define MSG_OOB		MSG_OOB
+    MSG_PEEK		= 0x02,	/* Peek at incoming messages.  */
+#define MSG_PEEK	MSG_PEEK
+    MSG_DONTROUTE	= 0x04,	/* Don't use local routing.  */
+#define MSG_DONTROUTE	MSG_DONTROUTE
+#ifdef __USE_GNU
+    /* DECnet uses a different name.  */
+    MSG_TRYHARD		= MSG_DONTROUTE,
+# define MSG_TRYHARD	MSG_DONTROUTE
+#endif
+    MSG_CTRUNC		= 0x08,	/* Control data lost before delivery.  */
+#define MSG_CTRUNC	MSG_CTRUNC
+    MSG_PROXY		= 0x10,	/* Supply or ask second address.  */
+#define MSG_PROXY	MSG_PROXY
+    MSG_TRUNC		= 0x20,
+#define	MSG_TRUNC	MSG_TRUNC
+    MSG_DONTWAIT	= 0x40, /* Nonblocking IO.  */
+#define	MSG_DONTWAIT	MSG_DONTWAIT
+    MSG_EOR		= 0x80, /* End of record.  */
+#define	MSG_EOR		MSG_EOR
+    MSG_WAITALL		= 0x100, /* Wait for a full request.  */
+#define	MSG_WAITALL	MSG_WAITALL
+    MSG_FIN		= 0x200,
+#define	MSG_FIN		MSG_FIN
+    MSG_SYN		= 0x400,
+#define	MSG_SYN		MSG_SYN
+    MSG_CONFIRM		= 0x800, /* Confirm path validity.  */
+#define	MSG_CONFIRM	MSG_CONFIRM
+    MSG_RST		= 0x1000,
+#define	MSG_RST		MSG_RST
+    MSG_ERRQUEUE	= 0x2000, /* Fetch message from error queue.  */
+#define	MSG_ERRQUEUE	MSG_ERRQUEUE
+    MSG_NOSIGNAL	= 0x4000, /* Do not generate SIGPIPE.  */
+#define	MSG_NOSIGNAL	MSG_NOSIGNAL
+    MSG_MORE		= 0x8000,  /* Sender will send more.  */
+#define	MSG_MORE	MSG_MORE
+
+    MSG_CMSG_CLOEXEC	= 0x40000000	/* Set close_on_exit for file
+                                           descriptor received through
+                                           SCM_RIGHTS.  */
+#define MSG_CMSG_CLOEXEC MSG_CMSG_CLOEXEC
+  };
+
+
+/* Structure describing messages sent by
+   `sendmsg' and received by `recvmsg'.  */
+struct msghdr
+  {
+    void *msg_name;		/* Address to send to/receive from.  */
+    socklen_t msg_namelen;	/* Length of address data.  */
+
+    struct iovec *msg_iov;	/* Vector of data to send/receive into.  */
+    size_t msg_iovlen;		/* Number of elements in the vector.  */
+
+    void *msg_control;		/* Ancillary data (eg BSD filedesc passing). */
+    size_t msg_controllen;	/* Ancillary data buffer length.
+				   !! The type should be socklen_t but the
+				   definition of the kernel is incompatible
+				   with this.  */
+
+    int msg_flags;		/* Flags on received message.  */
+  };
+
+/* Structure used for storage of ancillary data object information.  */
+struct cmsghdr
+  {
+    size_t cmsg_len;		/* Length of data in cmsg_data plus length
+				   of cmsghdr structure.
+				   !! The type should be socklen_t but the
+				   definition of the kernel is incompatible
+				   with this.  */
+    int cmsg_level;		/* Originating protocol.  */
+    int cmsg_type;		/* Protocol specific type.  */
+#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
+    __extension__ unsigned char __cmsg_data __flexarr; /* Ancillary data.  */
+#endif
+  };
+
+/* Ancillary data object manipulation macros.  */
+#if (!defined __STRICT_ANSI__ && __GNUC__ >= 2) || __STDC_VERSION__ >= 199901L
+# define CMSG_DATA(cmsg) ((cmsg)->__cmsg_data)
+#else
+# define CMSG_DATA(cmsg) ((unsigned char *) ((struct cmsghdr *) (cmsg) + 1))
+#endif
+#define CMSG_NXTHDR(mhdr, cmsg) __cmsg_nxthdr (mhdr, cmsg)
+#define CMSG_FIRSTHDR(mhdr) \
+  ((size_t) (mhdr)->msg_controllen >= sizeof (struct cmsghdr)		      \
+   ? (struct cmsghdr *) (mhdr)->msg_control : (struct cmsghdr *) NULL)
+#define CMSG_ALIGN(len) (((len) + sizeof (size_t) - 1) \
+			 & (size_t) ~(sizeof (size_t) - 1))
+#define CMSG_SPACE(len) (CMSG_ALIGN (len) \
+			 + CMSG_ALIGN (sizeof (struct cmsghdr)))
+#define CMSG_LEN(len)   (CMSG_ALIGN (sizeof (struct cmsghdr)) + (len))
+
+extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
+				      struct cmsghdr *__cmsg) __THROW;
+#ifdef __USE_EXTERN_INLINES
+# ifndef _EXTERN_INLINE
+#  define _EXTERN_INLINE __extern_inline
+# endif
+_EXTERN_INLINE struct cmsghdr *
+__NTH (__cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg))
+{
+  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))
+    /* The kernel header does this so there may be a reason.  */
+    return 0;
+
+  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
+			       + CMSG_ALIGN (__cmsg->cmsg_len));
+  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
+					+ __mhdr->msg_controllen)
+      || ((unsigned char *) __cmsg + CMSG_ALIGN (__cmsg->cmsg_len)
+	  > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))
+    /* No more entries.  */
+    return 0;
+  return __cmsg;
+}
+#endif	/* Use `extern inline'.  */
+
+/* Socket level message types.  This must match the definitions in
+   <linux/socket.h>.  */
+enum
+  {
+    SCM_RIGHTS = 0x01		/* Transfer file descriptors.  */
+#define SCM_RIGHTS SCM_RIGHTS
+#ifdef __USE_BSD
+    , SCM_CREDENTIALS = 0x02	/* Credentials passing.  */
+# define SCM_CREDENTIALS SCM_CREDENTIALS
+#endif
+  };
+
+/* User visible structure for SCM_CREDENTIALS message */
+
+struct ucred
+{
+  pid_t pid;			/* PID of sending process.  */
+  uid_t uid;			/* UID of sending process.  */
+  gid_t gid;			/* GID of sending process.  */
+};
+
+/* Get socket manipulation related informations from kernel headers.  */
+#include <asm/socket.h>
+
+
+/* Structure used to manipulate the SO_LINGER option.  */
+struct linger
+  {
+    int l_onoff;		/* Nonzero to linger on close.  */
+    int l_linger;		/* Time to linger.  */
+  };
+
+#endif	/* bits/socket.h */
diff -Naur iproute2-2.6.22-070710/include/linux/genetlink.h iproute2-mpls-1.1/include/linux/genetlink.h
--- iproute2-2.6.22-070710/include/linux/genetlink.h	2007-07-11 03:34:14.000000000 +0200
+++ iproute2-mpls-1.1/include/linux/genetlink.h	2008-11-02 11:50:36.000000000 +0100
@@ -39,6 +39,9 @@
 	CTRL_CMD_NEWOPS,
 	CTRL_CMD_DELOPS,
 	CTRL_CMD_GETOPS,
+	CTRL_CMD_NEWMCAST_GRP,
+	CTRL_CMD_DELMCAST_GRP,
+	CTRL_CMD_GETMCAST_GRP, /* unused */
 	__CTRL_CMD_MAX,
 };
 
@@ -52,6 +55,7 @@
 	CTRL_ATTR_HDRSIZE,
 	CTRL_ATTR_MAXATTR,
 	CTRL_ATTR_OPS,
+	CTRL_ATTR_MCAST_GROUPS,
 	__CTRL_ATTR_MAX,
 };
 
@@ -66,4 +70,44 @@
 
 #define CTRL_ATTR_OP_MAX (__CTRL_ATTR_OP_MAX - 1)
 
+enum {
+	CTRL_ATTR_MCAST_GRP_UNSPEC,
+	CTRL_ATTR_MCAST_GRP_NAME,
+	CTRL_ATTR_MCAST_GRP_ID,
+	__CTRL_ATTR_MCAST_GRP_MAX,
+};
+
+#define CTRL_ATTR_MCAST_GRP_MAX (__CTRL_ATTR_MCAST_GRP_MAX - 1)
+
+enum {
+	MPLS_CMD_UNSPEC,
+	MPLS_CMD_NEWILM,
+	MPLS_CMD_DELILM,
+	MPLS_CMD_GETILM,
+	MPLS_CMD_NEWNHLFE,
+	MPLS_CMD_DELNHLFE,
+	MPLS_CMD_GETNHLFE,
+	MPLS_CMD_NEWXC,
+	MPLS_CMD_DELXC,
+	MPLS_CMD_GETXC,
+	MPLS_CMD_SETLABELSPACE,
+	MPLS_CMD_GETLABELSPACE,
+	__MPLS_CMD_MAX,
+};
+
+#define MPLS_CMD_MAX (__MPLS_CMD_MAX - 1)
+
+enum {
+	MPLS_ATTR_UNSPEC,
+	MPLS_ATTR_ILM,
+	MPLS_ATTR_NHLFE,
+	MPLS_ATTR_XC,
+	MPLS_ATTR_LABELSPACE,
+	MPLS_ATTR_INSTR,
+	MPLS_ATTR_STATS,
+	__MPLS_ATTR_MAX,
+};
+
+#define MPLS_ATTR_MAX (__MPLS_ATTR_MAX - 1)
+
 #endif	/* __LINUX_GENERIC_NETLINK_H */
diff -Naur iproute2-2.6.22-070710/include/linux/if_addr.h iproute2-mpls-1.1/include/linux/if_addr.h
--- iproute2-2.6.22-070710/include/linux/if_addr.h	2007-07-11 03:34:14.000000000 +0200
+++ iproute2-mpls-1.1/include/linux/if_addr.h	2008-11-02 11:50:37.000000000 +0100
@@ -54,7 +54,9 @@
 };
 
 /* backwards compatibility for userspace */
+#ifndef __KERNEL__
 #define IFA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ifaddrmsg))))
 #define IFA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct ifaddrmsg))
+#endif
 
 #endif
diff -Naur iproute2-2.6.22-070710/include/linux/if_ether.h iproute2-mpls-1.1/include/linux/if_ether.h
--- iproute2-2.6.22-070710/include/linux/if_ether.h	1970-01-01 01:00:00.000000000 +0100
+++ iproute2-mpls-1.1/include/linux/if_ether.h	2008-11-02 11:50:36.000000000 +0100
@@ -0,0 +1,139 @@
+/*
+ * INET		An implementation of the TCP/IP protocol suite for the LINUX
+ *		operating system.  INET is implemented using the  BSD Socket
+ *		interface as the means of communication with the user level.
+ *
+ *		Global definitions for the Ethernet IEEE 802.3 interface.
+ *
+ * Version:	@(#)if_ether.h	1.0.1a	02/08/94
+ *
+ * Author:	Fred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>
+ *		Donald Becker, <becker@super.org>
+ *		Alan Cox, <alan@redhat.com>
+ *		Steve Whitehouse, <gw7rrm@eeshack3.swan.ac.uk>
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ */
+ 
+#ifndef _LINUX_IF_ETHER_H
+#define _LINUX_IF_ETHER_H
+
+#include <linux/types.h>
+
+/*
+ *	IEEE 802.3 Ethernet magic constants.  The frame sizes omit the preamble
+ *	and FCS/CRC (frame check sequence). 
+ */
+
+#define ETH_ALEN	6		/* Octets in one ethernet addr	 */
+#define ETH_HLEN	14		/* Total octets in header.	 */
+#define ETH_ZLEN	60		/* Min. octets in frame sans FCS */
+#define ETH_DATA_LEN	1500		/* Max. octets in payload	 */
+#define ETH_FRAME_LEN	1514		/* Max. octets in frame sans FCS */
+#define ETH_FCS_LEN	4		/* Octets in the FCS		 */
+
+/*
+ *	These are the defined Ethernet Protocol ID's.
+ */
+
+#define ETH_P_LOOP	0x0060		/* Ethernet Loopback packet	*/
+#define ETH_P_PUP	0x0200		/* Xerox PUP packet		*/
+#define ETH_P_PUPAT	0x0201		/* Xerox PUP Addr Trans packet	*/
+#define ETH_P_IP	0x0800		/* Internet Protocol packet	*/
+#define ETH_P_X25	0x0805		/* CCITT X.25			*/
+#define ETH_P_ARP	0x0806		/* Address Resolution packet	*/
+#define	ETH_P_BPQ	0x08FF		/* G8BPQ AX.25 Ethernet Packet	[ NOT AN OFFICIALLY REGISTERED ID ] */
+#define ETH_P_IEEEPUP	0x0a00		/* Xerox IEEE802.3 PUP packet */
+#define ETH_P_IEEEPUPAT	0x0a01		/* Xerox IEEE802.3 PUP Addr Trans packet */
+#define ETH_P_DEC       0x6000          /* DEC Assigned proto           */
+#define ETH_P_DNA_DL    0x6001          /* DEC DNA Dump/Load            */
+#define ETH_P_DNA_RC    0x6002          /* DEC DNA Remote Console       */
+#define ETH_P_DNA_RT    0x6003          /* DEC DNA Routing              */
+#define ETH_P_LAT       0x6004          /* DEC LAT                      */
+#define ETH_P_DIAG      0x6005          /* DEC Diagnostics              */
+#define ETH_P_CUST      0x6006          /* DEC Customer use             */
+#define ETH_P_SCA       0x6007          /* DEC Systems Comms Arch       */
+#define ETH_P_RARP      0x8035		/* Reverse Addr Res packet	*/
+#define ETH_P_ATALK	0x809B		/* Appletalk DDP		*/
+#define ETH_P_AARP	0x80F3		/* Appletalk AARP		*/
+#define ETH_P_8021Q	0x8100          /* 802.1Q VLAN Extended Header  */
+#define ETH_P_IPX	0x8137		/* IPX over DIX			*/
+#define ETH_P_IPV6	0x86DD		/* IPv6 over bluebook		*/
+#define ETH_P_PAUSE	0x8808		/* IEEE Pause frames. See 802.3 31B */
+#define ETH_P_SLOW	0x8809		/* Slow Protocol. See 802.3ad 43B */
+#define ETH_P_WCCP	0x883E		/* Web-cache coordination protocol
+					 * defined in draft-wilson-wrec-wccp-v2-00.txt */
+#define ETH_P_PPP_DISC	0x8863		/* PPPoE discovery messages     */
+#define ETH_P_PPP_SES	0x8864		/* PPPoE session messages	*/
+#define ETH_P_MPLS_UC	0x8847		/* MPLS Unicast traffic		*/
+#define ETH_P_MPLS_MC	0x8848		/* MPLS Multicast traffic	*/
+#define ETH_P_ATMMPOA	0x884c		/* MultiProtocol Over ATM	*/
+#define ETH_P_ATMFATE	0x8884		/* Frame-based ATM Transport
+					 * over Ethernet
+					 */
+#define ETH_P_AOE	0x88A2		/* ATA over Ethernet		*/
+#define ETH_P_TIPC	0x88CA		/* TIPC 			*/
+
+/*
+ *	Non DIX types. Won't clash for 1500 types.
+ */
+ 
+#define ETH_P_802_3	0x0001		/* Dummy type for 802.3 frames  */
+#define ETH_P_AX25	0x0002		/* Dummy protocol id for AX.25  */
+#define ETH_P_ALL	0x0003		/* Every packet (be careful!!!) */
+#define ETH_P_802_2	0x0004		/* 802.2 frames 		*/
+#define ETH_P_SNAP	0x0005		/* Internal only		*/
+#define ETH_P_DDCMP     0x0006          /* DEC DDCMP: Internal only     */
+#define ETH_P_WAN_PPP   0x0007          /* Dummy type for WAN PPP frames*/
+#define ETH_P_PPP_MP    0x0008          /* Dummy type for PPP MP frames */
+#define ETH_P_LOCALTALK 0x0009		/* Localtalk pseudo type 	*/
+#define ETH_P_CAN	0x000C		/* Controller Area Network      */
+#define ETH_P_PPPTALK	0x0010		/* Dummy type for Atalk over PPP*/
+#define ETH_P_TR_802_2	0x0011		/* 802.2 frames 		*/
+#define ETH_P_MOBITEX	0x0015		/* Mobitex (kaz@cafe.net)	*/
+#define ETH_P_CONTROL	0x0016		/* Card specific control frames */
+#define ETH_P_IRDA	0x0017		/* Linux-IrDA			*/
+#define ETH_P_ECONET	0x0018		/* Acorn Econet			*/
+#define ETH_P_HDLC	0x0019		/* HDLC frames			*/
+#define ETH_P_ARCNET	0x001A		/* 1A for ArcNet :-)            */
+
+/*
+ *	This is an Ethernet frame header.
+ */
+ 
+struct ethhdr {
+	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
+	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
+	__be16		h_proto;		/* packet type ID field	*/
+} __attribute__((packed));
+
+#ifdef __KERNEL__
+#include <linux/skbuff.h>
+
+static inline struct ethhdr *eth_hdr(const struct sk_buff *skb)
+{
+	return (struct ethhdr *)skb_mac_header(skb);
+}
+
+int eth_header_parse(const struct sk_buff *skb, unsigned char *haddr);
+
+#ifdef CONFIG_SYSCTL
+extern struct ctl_table ether_table[];
+#endif
+
+extern ssize_t sysfs_format_mac(char *buf, const unsigned char *addr, int len);
+
+/*
+ *	Display a 6 byte device address (MAC) in a readable format.
+ */
+extern char *print_mac(char *buf, const unsigned char *addr);
+#define MAC_FMT "%02x:%02x:%02x:%02x:%02x:%02x"
+#define MAC_BUF_SIZE	18
+#define DECLARE_MAC_BUF(var) char var[MAC_BUF_SIZE] __maybe_unused
+
+#endif
+
+#endif	/* _LINUX_IF_ETHER_H */
diff -Naur iproute2-2.6.22-070710/include/linux/if_link.h iproute2-mpls-1.1/include/linux/if_link.h
--- iproute2-2.6.22-070710/include/linux/if_link.h	2007-07-11 03:34:14.000000000 +0200
+++ iproute2-mpls-1.1/include/linux/if_link.h	2008-11-02 11:50:37.000000000 +0100
@@ -76,6 +76,9 @@
 #define IFLA_WEIGHT IFLA_WEIGHT
 	IFLA_OPERSTATE,
 	IFLA_LINKMODE,
+	IFLA_LINKINFO,
+#define IFLA_LINKINFO IFLA_LINKINFO
+	IFLA_NET_NS_PID,
 	__IFLA_MAX
 };
 
@@ -83,8 +86,10 @@
 #define IFLA_MAX (__IFLA_MAX - 1)
 
 /* backwards compatibility for userspace */
+#ifndef __KERNEL__
 #define IFLA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct ifinfomsg))))
 #define IFLA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct ifinfomsg))
+#endif
 
 /* ifi_flags.
 
@@ -138,4 +143,49 @@
 	__u32	retrans_time;
 };
 
+enum
+{
+	IFLA_INFO_UNSPEC,
+	IFLA_INFO_KIND,
+	IFLA_INFO_DATA,
+	IFLA_INFO_XSTATS,
+	__IFLA_INFO_MAX,
+};
+
+#define IFLA_INFO_MAX	(__IFLA_INFO_MAX - 1)
+
+/* VLAN section */
+
+enum
+{
+	IFLA_VLAN_UNSPEC,
+	IFLA_VLAN_ID,
+	IFLA_VLAN_FLAGS,
+	IFLA_VLAN_EGRESS_QOS,
+	IFLA_VLAN_INGRESS_QOS,
+	__IFLA_VLAN_MAX,
+};
+
+#define IFLA_VLAN_MAX	(__IFLA_VLAN_MAX - 1)
+
+struct ifla_vlan_flags {
+	__u32	flags;
+	__u32	mask;
+};
+
+enum
+{
+	IFLA_VLAN_QOS_UNSPEC,
+	IFLA_VLAN_QOS_MAPPING,
+	__IFLA_VLAN_QOS_MAX
+};
+
+#define IFLA_VLAN_QOS_MAX	(__IFLA_VLAN_QOS_MAX - 1)
+
+struct ifla_vlan_qos_mapping
+{
+	__u32 from;
+	__u32 to;
+};
+
 #endif /* _LINUX_IF_LINK_H */
diff -Naur iproute2-2.6.22-070710/include/linux/mpls.h iproute2-mpls-1.1/include/linux/mpls.h
--- iproute2-2.6.22-070710/include/linux/mpls.h	1970-01-01 01:00:00.000000000 +0100
+++ iproute2-mpls-1.1/include/linux/mpls.h	2008-11-02 11:50:36.000000000 +0100
@@ -0,0 +1,248 @@
+/*****************************************************************************
+ * MPLS
+ *      An implementation of the MPLS (MultiProtocol Label
+ *      Switching Architecture) for Linux.
+ *
+ * Authors:
+ *          James Leu        <jleu@mindspring.com>
+ *          Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ *   (c) 1999-2004   James Leu        <jleu@mindspring.com>
+ *   (c) 2003-2004   Ramon Casellas   <casellas@infres.enst.fr>
+ *
+ * include/linux/mpls.h
+ *      Data types and structs used by userspace programs to access MPLS
+ *      forwarding. Most interface with the MPLS subsystem is IOCTL based
+ *
+ *      This program is free software; you can redistribute it and/or
+ *      modify it under the terms of the GNU General Public License
+ *      as published by the Free Software Foundation; either version
+ *      2 of the License, or (at your option) any later version.
+ ****************************************************************************/
+
+#ifndef _LINUX_MPLS_H_
+#define _LINUX_MPLS_H_
+
+#ifdef __KERNEL__
+#include <linux/socket.h>
+#include <linux/if.h>
+#else
+#include <sys/socket.h>
+#include <linux/types.h>
+#include <net/if.h>
+#endif
+
+#define MPLS_NUM_OPS		8
+
+#define MPLS_LINUX_VERSION	0x01090602
+
+#define	MPLS_GRP_ILM	1
+#define	MPLS_GRP_NHLFE	2
+#define	MPLS_GRP_XC	4
+#define	MPLS_GRP_LABELSPACE 8
+
+#define MPLS_IPV4_EXPLICIT_NULL	0       /* only valid as sole label stack entry
+					   Pop label and send to IPv4 stack */
+#define MPLS_ROUTER_ALERT	1       /* anywhere except bottom, packet it is
+					   forwared to a software module
+					   determined by the next label,
+					   if the packet is forwarded, push this
+					   label back on */
+#define MPLS_IPV6_EXPLICIT_NULL	2       /* only valid as sole label stack entry
+					   Pop label and send to IPv6 stack */
+#define MPLS_IMPLICIT_NULL	3       /* a LIB with this, signifies to pop
+					   the next label and use that */
+
+#define MPLS_CHANGE_MTU		0x01
+#define MPLS_CHANGE_PROP_TTL	0x02
+#define MPLS_CHANGE_INSTR	0x04
+#define MPLS_CHANGE_PROTO	0x10
+
+enum mpls_dir {
+	MPLS_IN = 0x10,
+	MPLS_OUT = 0x20
+};
+
+enum mpls_opcode_enum {
+	MPLS_OP_NOP = 0x00,
+	MPLS_OP_POP,
+	MPLS_OP_PEEK,
+	MPLS_OP_PUSH,
+	MPLS_OP_DLV,
+	MPLS_OP_FWD,
+	MPLS_OP_NF_FWD,
+	MPLS_OP_DS_FWD,
+	MPLS_OP_EXP_FWD,
+	MPLS_OP_SET,
+	MPLS_OP_SET_RX,
+	MPLS_OP_SET_TC,
+	MPLS_OP_SET_DS,
+	MPLS_OP_SET_EXP,
+	MPLS_OP_EXP2TC,
+	MPLS_OP_EXP2DS,
+	MPLS_OP_TC2EXP,
+	MPLS_OP_DS2EXP,
+	MPLS_OP_NF2EXP,
+	MPLS_OP_SET_NF,
+	MPLS_OP_MAX
+};
+
+enum mpls_label_type_enum {
+	MPLS_LABEL_GEN = 1,
+	MPLS_LABEL_ATM,
+	MPLS_LABEL_FR,
+	MPLS_LABEL_KEY
+};
+
+struct mpls_label_atm {
+	u_int16_t  mla_vpi;
+	u_int16_t  mla_vci;
+};
+
+struct mpls_label {
+	enum mpls_label_type_enum ml_type;
+	union {
+		u_int32_t ml_key;
+		u_int32_t ml_gen;
+		u_int32_t ml_fr;
+		struct mpls_label_atm ml_atm;
+	} u;
+	int ml_index;
+};
+
+struct mpls_in_label_req {
+	unsigned int      mil_proto;
+	struct mpls_label mil_label;
+	unsigned char     mil_change_flag;
+};
+
+#define MPLS_LABELSPACE_MAX	255
+
+struct mpls_labelspace_req {
+	int mls_ifindex;                  /* Index to the MPLS-enab. interface*/
+	int mls_labelspace;               /* Labelspace IN/SET -- OUT/GET     */
+};
+
+struct mpls_nexthop_info {
+	unsigned int    mni_if;
+	struct sockaddr mni_addr;
+};
+
+struct mpls_out_label_req {
+	struct mpls_label mol_label;
+	u_int32_t         mol_mtu;
+	int8_t            mol_propagate_ttl;
+	unsigned char     mol_change_flag;
+};
+
+struct mpls_xconnect_req {
+	struct mpls_label mx_in;
+	struct mpls_label mx_out;
+};
+
+struct mpls_tunnel_req {
+	char mt_ifname[IFNAMSIZ];
+	unsigned int mt_nhlfe_key;
+};
+
+#define MPLS_NFMARK_NUM 64
+
+struct mpls_nfmark_fwd {
+	unsigned int nf_key[MPLS_NFMARK_NUM];
+	unsigned short nf_mask;
+};
+
+#define MPLS_DSMARK_NUM 64
+
+struct mpls_dsmark_fwd {
+	unsigned int df_key[MPLS_DSMARK_NUM];
+	unsigned char df_mask;
+};
+
+#define MPLS_TCINDEX_NUM 64
+
+struct mpls_tcindex_fwd {
+	unsigned int tc_key[MPLS_TCINDEX_NUM];
+	unsigned short tc_mask;
+};
+
+#define MPLS_EXP_NUM 8
+
+struct mpls_exp_fwd {
+	unsigned int ef_key[MPLS_EXP_NUM];
+};
+
+struct mpls_exp2tcindex {
+	unsigned short e2t[MPLS_EXP_NUM];
+};
+
+struct mpls_exp2dsmark {
+	unsigned char e2d[MPLS_EXP_NUM];
+};
+
+struct mpls_tcindex2exp {
+	unsigned char t2e_mask;
+	unsigned char t2e[MPLS_TCINDEX_NUM];
+};
+
+struct mpls_dsmark2exp {
+	unsigned char d2e_mask;
+	unsigned char d2e[MPLS_DSMARK_NUM];
+};
+
+struct mpls_nfmark2exp {
+	unsigned char n2e_mask;
+	unsigned char n2e[MPLS_NFMARK_NUM];
+};
+
+struct mpls_instr_elem {
+	unsigned short mir_opcode;
+	unsigned char mir_direction;
+	union {
+		struct mpls_label        push;
+		struct mpls_label        fwd;
+		struct mpls_nfmark_fwd   nf_fwd;
+		struct mpls_dsmark_fwd   ds_fwd;
+		struct mpls_exp_fwd      exp_fwd;
+		struct mpls_nexthop_info set;
+		unsigned int             set_rx;
+		unsigned short           set_tc;
+		unsigned short           set_ds;
+		unsigned char            set_exp;
+		struct mpls_exp2tcindex  exp2tc;
+		struct mpls_exp2dsmark   exp2ds;
+		struct mpls_tcindex2exp  tc2exp;
+		struct mpls_dsmark2exp   ds2exp;
+		struct mpls_nfmark2exp   nf2exp;
+		unsigned long            set_nf;
+	} mir_data;
+};
+
+/* Standard shortcuts */
+#define mir_push       mir_data.push
+#define mir_fwd        mir_data.fwd
+#define mir_nf_fwd     mir_data.nf_fwd
+#define mir_ds_fwd     mir_data.ds_fwd
+#define mir_exp_fwd    mir_data.exp_fwd
+#define mir_set        mir_data.set
+#define mir_set_rx     mir_data.set_rx
+#define mir_set_tc     mir_data.set_tc
+#define mir_set_tx     mir_data.set_tx
+#define mir_set_ds     mir_data.set_ds
+#define mir_set_exp    mir_data.set_exp
+#define mir_set_nf     mir_data.set_nf
+#define mir_exp2tc     mir_data.exp2tc
+#define mir_exp2ds     mir_data.exp2ds
+#define mir_tc2exp     mir_data.tc2exp
+#define mir_ds2exp     mir_data.ds2exp
+#define mir_nf2exp     mir_data.nf2exp
+
+struct mpls_instr_req {
+	struct mpls_instr_elem       mir_instr[MPLS_NUM_OPS];
+	unsigned char                mir_instr_length;
+	unsigned char                mir_direction;
+	int                          mir_index;
+	struct mpls_label            mir_label;
+};
+
+#endif
diff -Naur iproute2-2.6.22-070710/include/linux/rtnetlink.h iproute2-mpls-1.1/include/linux/rtnetlink.h
--- iproute2-2.6.22-070710/include/linux/rtnetlink.h	2007-07-11 03:34:14.000000000 +0200
+++ iproute2-mpls-1.1/include/linux/rtnetlink.h	2008-11-02 12:10:16.000000000 +0100
@@ -97,6 +97,16 @@
 	RTM_SETNEIGHTBL,
 #define RTM_SETNEIGHTBL	RTM_SETNEIGHTBL
 
+	RTM_NEWNDUSEROPT = 68,
+#define RTM_NEWNDUSEROPT RTM_NEWNDUSEROPT
+
+	RTM_NEWADDRLABEL = 72,
+#define RTM_NEWADDRLABEL RTM_NEWADDRLABEL
+	RTM_DELADDRLABEL,
+#define RTM_NEWADDRLABEL RTM_NEWADDRLABEL
+	RTM_GETADDRLABEL,
+#define RTM_GETADDRLABEL RTM_GETADDRLABEL
+
 	__RTM_MAX,
 #define RTM_MAX		(((__RTM_MAX + 3) & ~3) - 1)
 };
@@ -236,6 +246,7 @@
 {
 	RT_TABLE_UNSPEC=0,
 /* User defined values */
+	RT_TABLE_COMPAT=252,
 	RT_TABLE_DEFAULT=253,
 	RT_TABLE_MAIN=254,
 	RT_TABLE_LOCAL=255,
@@ -257,13 +268,14 @@
 	RTA_PREFSRC,
 	RTA_METRICS,
 	RTA_MULTIPATH,
-	RTA_PROTOINFO,
+	RTA_PROTOINFO, /* no longer used */
 	RTA_FLOW,
 	RTA_CACHEINFO,
-	RTA_SESSION,
-	RTA_MP_ALGO,
+	RTA_SESSION, /* no longer used */
+	RTA_MP_ALGO, /* no longer used */
 	RTA_TABLE,
 	RTA_FWMASK,
+	RTA_SHIM = 30,
 	__RTA_MAX
 };
 
@@ -352,6 +364,8 @@
 #define RTAX_INITCWND RTAX_INITCWND
 	RTAX_FEATURES,
 #define RTAX_FEATURES RTAX_FEATURES
+	RTAX_RTO_MIN,
+#define RTAX_RTO_MIN RTAX_RTO_MIN
 	__RTAX_MAX
 };
 
@@ -478,6 +492,33 @@
 #define TCA_RTA(r)  ((struct rtattr*)(((char*)(r)) + NLMSG_ALIGN(sizeof(struct tcmsg))))
 #define TCA_PAYLOAD(n) NLMSG_PAYLOAD(n,sizeof(struct tcmsg))
 
+/********************************************************************
+ *		Neighbor Discovery userland options
+ ****/
+
+struct nduseroptmsg
+{
+	unsigned char	nduseropt_family;
+	unsigned char	nduseropt_pad1;
+	unsigned short	nduseropt_opts_len;	/* Total length of options */
+	int		nduseropt_ifindex;
+	__u8		nduseropt_icmp_type;
+	__u8		nduseropt_icmp_code;
+	unsigned short	nduseropt_pad2;
+	unsigned int	nduseropt_pad3;
+	/* Followed by one or more ND options */
+};
+
+enum
+{
+	NDUSEROPT_UNSPEC,
+	NDUSEROPT_SRCADDR,
+	__NDUSEROPT_MAX
+};
+
+#define NDUSEROPT_MAX	(__NDUSEROPT_MAX - 1)
+
+#ifndef __KERNEL__
 /* RTnetlink multicast groups - backwards compatibility for userspace */
 #define RTMGRP_LINK		1
 #define RTMGRP_NOTIFY		2
@@ -498,6 +539,7 @@
 #define RTMGRP_DECnet_ROUTE     0x4000
 
 #define RTMGRP_IPV6_PREFIX	0x20000
+#endif
 
 /* RTnetlink multicast groups */
 enum rtnetlink_groups {
@@ -539,6 +581,8 @@
 #define RTNLGRP_IPV6_PREFIX	RTNLGRP_IPV6_PREFIX
 	RTNLGRP_IPV6_RULE,
 #define RTNLGRP_IPV6_RULE	RTNLGRP_IPV6_RULE
+	RTNLGRP_ND_USEROPT,
+#define RTNLGRP_ND_USEROPT	RTNLGRP_ND_USEROPT
 	__RTNLGRP_MAX
 };
 #define RTNLGRP_MAX	(__RTNLGRP_MAX - 1)
@@ -557,6 +601,176 @@
 
 /* End of information exported to user level */
 
+#ifdef __KERNEL__
+
+#include <linux/mutex.h>
+
+static __inline__ int rtattr_strcmp(const struct rtattr *rta, const char *str)
+{
+	int len = strlen(str) + 1;
+	return len > rta->rta_len || memcmp(RTA_DATA(rta), str, len);
+}
+
+extern int rtnetlink_send(struct sk_buff *skb, struct net *net, u32 pid, u32 group, int echo);
+extern int rtnl_unicast(struct sk_buff *skb, struct net *net, u32 pid);
+extern int rtnl_notify(struct sk_buff *skb, struct net *net, u32 pid, u32 group,
+		       struct nlmsghdr *nlh, gfp_t flags);
+extern void rtnl_set_sk_err(struct net *net, u32 group, int error);
+extern int rtnetlink_put_metrics(struct sk_buff *skb, u32 *metrics);
+extern int rtnl_put_cacheinfo(struct sk_buff *skb, struct dst_entry *dst,
+			      u32 id, u32 ts, u32 tsage, long expires,
+			      u32 error);
+
+extern void __rta_fill(struct sk_buff *skb, int attrtype, int attrlen, const void *data);
+
+#define RTA_PUT(skb, attrtype, attrlen, data) \
+({	if (unlikely(skb_tailroom(skb) < (int)RTA_SPACE(attrlen))) \
+		 goto rtattr_failure; \
+   	__rta_fill(skb, attrtype, attrlen, data); }) 
+
+#define RTA_APPEND(skb, attrlen, data) \
+({	if (unlikely(skb_tailroom(skb) < (int)(attrlen))) \
+		goto rtattr_failure; \
+	memcpy(skb_put(skb, attrlen), data, attrlen); })
+
+#define RTA_PUT_NOHDR(skb, attrlen, data) \
+({	RTA_APPEND(skb, RTA_ALIGN(attrlen), data); \
+	memset(skb_tail_pointer(skb) - (RTA_ALIGN(attrlen) - attrlen), 0, \
+	       RTA_ALIGN(attrlen) - attrlen); })
+
+#define RTA_PUT_U8(skb, attrtype, value) \
+({	u8 _tmp = (value); \
+	RTA_PUT(skb, attrtype, sizeof(u8), &_tmp); })
+
+#define RTA_PUT_U16(skb, attrtype, value) \
+({	u16 _tmp = (value); \
+	RTA_PUT(skb, attrtype, sizeof(u16), &_tmp); })
+
+#define RTA_PUT_U32(skb, attrtype, value) \
+({	u32 _tmp = (value); \
+	RTA_PUT(skb, attrtype, sizeof(u32), &_tmp); })
+
+#define RTA_PUT_U64(skb, attrtype, value) \
+({	u64 _tmp = (value); \
+	RTA_PUT(skb, attrtype, sizeof(u64), &_tmp); })
+
+#define RTA_PUT_SECS(skb, attrtype, value) \
+	RTA_PUT_U64(skb, attrtype, (value) / HZ)
+
+#define RTA_PUT_MSECS(skb, attrtype, value) \
+	RTA_PUT_U64(skb, attrtype, jiffies_to_msecs(value))
+
+#define RTA_PUT_STRING(skb, attrtype, value) \
+	RTA_PUT(skb, attrtype, strlen(value) + 1, value)
+
+#define RTA_PUT_FLAG(skb, attrtype) \
+	RTA_PUT(skb, attrtype, 0, NULL);
+
+#define RTA_NEST(skb, type) \
+({	struct rtattr *__start = (struct rtattr *)skb_tail_pointer(skb); \
+	RTA_PUT(skb, type, 0, NULL); \
+	__start;  })
+
+#define RTA_NEST_END(skb, start) \
+({	(start)->rta_len = skb_tail_pointer(skb) - (unsigned char *)(start); \
+	(skb)->len; })
+
+#define RTA_NEST_COMPAT(skb, type, attrlen, data) \
+({	struct rtattr *__start = (struct rtattr *)skb_tail_pointer(skb); \
+	RTA_PUT(skb, type, attrlen, data); \
+	RTA_NEST(skb, type); \
+	__start; })
+
+#define RTA_NEST_COMPAT_END(skb, start) \
+({	struct rtattr *__nest = (void *)(start) + NLMSG_ALIGN((start)->rta_len); \
+	(start)->rta_len = skb_tail_pointer(skb) - (unsigned char *)(start); \
+	RTA_NEST_END(skb, __nest); \
+	(skb)->len; })
+
+#define RTA_NEST_CANCEL(skb, start) \
+({	if (start) \
+		skb_trim(skb, (unsigned char *) (start) - (skb)->data); \
+	-1; })
+
+#define RTA_GET_U8(rta) \
+({	if (!rta || RTA_PAYLOAD(rta) < sizeof(u8)) \
+		goto rtattr_failure; \
+	*(u8 *) RTA_DATA(rta); })
+
+#define RTA_GET_U16(rta) \
+({	if (!rta || RTA_PAYLOAD(rta) < sizeof(u16)) \
+		goto rtattr_failure; \
+	*(u16 *) RTA_DATA(rta); })
+
+#define RTA_GET_U32(rta) \
+({	if (!rta || RTA_PAYLOAD(rta) < sizeof(u32)) \
+		goto rtattr_failure; \
+	*(u32 *) RTA_DATA(rta); })
+
+#define RTA_GET_U64(rta) \
+({	u64 _tmp; \
+	if (!rta || RTA_PAYLOAD(rta) < sizeof(u64)) \
+		goto rtattr_failure; \
+	memcpy(&_tmp, RTA_DATA(rta), sizeof(_tmp)); \
+	_tmp; })
+
+#define RTA_GET_FLAG(rta) (!!(rta))
+
+#define RTA_GET_SECS(rta) ((unsigned long) RTA_GET_U64(rta) * HZ)
+#define RTA_GET_MSECS(rta) (msecs_to_jiffies((unsigned long) RTA_GET_U64(rta)))
+		
+static inline struct rtattr *
+__rta_reserve(struct sk_buff *skb, int attrtype, int attrlen)
+{
+	struct rtattr *rta;
+	int size = RTA_LENGTH(attrlen);
+
+	rta = (struct rtattr*)skb_put(skb, RTA_ALIGN(size));
+	rta->rta_type = attrtype;
+	rta->rta_len = size;
+	memset(RTA_DATA(rta) + attrlen, 0, RTA_ALIGN(size) - size);
+	return rta;
+}
+
+#define __RTA_PUT(skb, attrtype, attrlen) \
+({ 	if (unlikely(skb_tailroom(skb) < (int)RTA_SPACE(attrlen))) \
+		goto rtattr_failure; \
+   	__rta_reserve(skb, attrtype, attrlen); })
+
+extern void rtmsg_ifinfo(int type, struct net_device *dev, unsigned change);
+
+/* RTNL is used as a global lock for all changes to network configuration  */
+extern void rtnl_lock(void);
+extern void rtnl_unlock(void);
+extern int rtnl_trylock(void);
+extern int rtnl_is_locked(void);
+
+extern void rtnetlink_init(void);
+extern void __rtnl_unlock(void);
+
+#define ASSERT_RTNL() do { \
+	if (unlikely(!rtnl_is_locked())) { \
+		printk(KERN_ERR "RTNL: assertion failed at %s (%d)\n", \
+		       __FILE__,  __LINE__); \
+		dump_stack(); \
+	} \
+} while(0)
+
+#define BUG_TRAP(x) do { \
+	if (unlikely(!(x))) { \
+		printk(KERN_ERR "KERNEL: assertion (%s) failed at %s (%d)\n", \
+			#x,  __FILE__ , __LINE__); \
+	} \
+} while(0)
+
+static inline u32 rtm_get_table(struct rtattr **rta, u8 table)
+{
+	return RTA_GET_U32(rta[RTA_TABLE-1]);
+rtattr_failure:
+	return table;
+}
+
+#endif /* __KERNEL__ */
 
 
 #endif	/* __LINUX_RTNETLINK_H */
diff -Naur iproute2-2.6.22-070710/include/linux/shim.h iproute2-mpls-1.1/include/linux/shim.h
--- iproute2-2.6.22-070710/include/linux/shim.h	1970-01-01 01:00:00.000000000 +0100
+++ iproute2-mpls-1.1/include/linux/shim.h	2008-11-02 11:50:37.000000000 +0100
@@ -0,0 +1,12 @@
+#ifndef LINUX_SHIM_H
+#define LINUX_SHIM_H
+
+#define SHIMNAMSIZ 16
+struct rtshim
+{
+	char name[SHIMNAMSIZ+1];
+	short datalen;
+	char data[0];
+};
+
+#endif
diff -Naur iproute2-2.6.22-070710/include/linux/socket.h iproute2-mpls-1.1/include/linux/socket.h
--- iproute2-2.6.22-070710/include/linux/socket.h	2007-07-11 03:34:14.000000000 +0200
+++ iproute2-mpls-1.1/include/linux/socket.h	2008-11-02 11:50:37.000000000 +0100
@@ -22,8 +22,8 @@
 #include <linux/sockios.h>		/* the SIOCxxx I/O controls	*/
 #include <linux/uio.h>			/* iovec support		*/
 #include <linux/types.h>		/* pid_t			*/
+#include <linux/compiler.h>		/* __user			*/
 
-extern int sysctl_somaxconn;
 #ifdef CONFIG_PROC_FS
 struct seq_file;
 extern void socket_seq_show(struct seq_file *seq);
@@ -102,7 +102,9 @@
  *	This mess will go away with glibc
  */
  
-#if    defined(__GNUC__) 
+#ifdef __KERNEL__
+#define __KINLINE static inline
+#elif  defined(__GNUC__) 
 #define __KINLINE static __inline__
 #elif defined(__cplusplus)
 #define __KINLINE static inline
@@ -182,6 +184,8 @@
 #define AF_PPPOX	24	/* PPPoX sockets		*/
 #define AF_WANPIPE	25	/* Wanpipe API Sockets */
 #define AF_LLC		26	/* Linux LLC			*/
+#define AF_MPLS		28	/* MPLS sockets			*/
+#define AF_CAN		29	/* Controller Area Network      */
 #define AF_TIPC		30	/* TIPC sockets			*/
 #define AF_BLUETOOTH	31	/* Bluetooth sockets 		*/
 #define AF_IUCV		32	/* IUCV sockets			*/
@@ -217,6 +221,8 @@
 #define PF_PPPOX	AF_PPPOX
 #define PF_WANPIPE	AF_WANPIPE
 #define PF_LLC		AF_LLC
+#define PF_MPLS		AF_MPLS
+#define PF_CAN		AF_CAN
 #define PF_TIPC		AF_TIPC
 #define PF_BLUETOOTH	AF_BLUETOOTH
 #define PF_IUCV		AF_IUCV
@@ -250,6 +256,9 @@
 
 #define MSG_EOF         MSG_FIN
 
+#define MSG_CMSG_CLOEXEC 0x40000000	/* Set close_on_exit for file
+					   descriptor received through
+					   SCM_RIGHTS */
 #if defined(CONFIG_COMPAT)
 #define MSG_CMSG_COMPAT	0x80000000	/* This message needs 32 bit fixups */
 #else
@@ -284,9 +293,27 @@
 #define SOL_NETLINK	270
 #define SOL_TIPC	271
 #define SOL_RXRPC	272
+#define SOL_PPPOL2TP	273
+#define SOL_BLUETOOTH	274
 
 /* IPX options */
 #define IPX_TYPE	1
 
+#ifdef __KERNEL__
+extern int memcpy_fromiovec(unsigned char *kdata, struct iovec *iov, int len);
+extern int memcpy_fromiovecend(unsigned char *kdata, struct iovec *iov, 
+				int offset, int len);
+extern int csum_partial_copy_fromiovecend(unsigned char *kdata, 
+					  struct iovec *iov, 
+					  int offset, 
+					  unsigned int len, __wsum *csump);
+
+extern int verify_iovec(struct msghdr *m, struct iovec *iov, char *address, int mode);
+extern int memcpy_toiovec(struct iovec *v, unsigned char *kdata, int len);
+extern int move_addr_to_user(void *kaddr, int klen, void __user *uaddr, int __user *ulen);
+extern int move_addr_to_kernel(void __user *uaddr, int ulen, void *kaddr);
+extern int put_cmsg(struct msghdr*, int level, int type, int len, void *data);
+
+#endif
 #endif /* not kernel and not glibc */
 #endif /* _LINUX_SOCKET_H */
diff -Naur iproute2-2.6.22-070710/ip/iproute.c iproute2-mpls-1.1/ip/iproute.c
--- iproute2-2.6.22-070710/ip/iproute.c	2007-07-11 03:34:14.000000000 +0200
+++ iproute2-mpls-1.1/ip/iproute.c	2008-10-07 14:40:30.000000000 +0200
@@ -29,6 +29,7 @@
 #include <arpa/inet.h>
 #include <linux/in_route.h>
 #include <linux/ip_mp_alg.h>
+#include <linux/shim.h>
 
 #include "rt_names.h"
 #include "utils.h"
@@ -69,7 +70,8 @@
 	fprintf(stderr, "             [ scope SCOPE ] [ metric METRIC ]\n");
 	fprintf(stderr, "             [ mpath MP_ALGO ]\n");
 	fprintf(stderr, "INFO_SPEC := NH OPTIONS FLAGS [ nexthop NH ]...\n");
-	fprintf(stderr, "NH := [ via ADDRESS ] [ dev STRING ] [ weight NUMBER ] NHFLAGS\n");
+	fprintf(stderr, "NH := [ via ADDRESS ] [ dev STRING ] [ weight NUMBER ]\n");
+	fprintf(stderr, "      [ shim STRING STRING ] [ mpls NUMBER ] NHFLAGS\n");
 	fprintf(stderr, "OPTIONS := FLAGS [ mtu NUMBER ] [ advmss NUMBER ]\n");
 	fprintf(stderr, "           [ rtt NUMBER ] [ rttvar NUMBER ]\n");
 	fprintf(stderr, "           [ window NUMBER] [ cwnd NUMBER ] [ initcwnd NUMBER ]\n");
@@ -107,6 +109,8 @@
 	inet_prefix mdst;
 	inet_prefix rsrc;
 	inet_prefix msrc;
+	unsigned int mpls;
+	char *shim_name;
 } filter;
 
 static char *mp_alg_names[IP_MP_ALG_MAX+1] = {
@@ -281,6 +285,19 @@
 		if ((oif^filter.oif)&filter.oifmask)
 			return 0;
 	}
+	if (filter.mpls) {
+		struct rtshim *shim = NULL;
+		if (tb[RTA_SHIM])
+			shim = RTA_DATA(tb[RTA_SHIM]);
+		if (shim && !memcmp(&filter.mpls, shim->data, shim->datalen)) 
+			return 0;
+	} else if (filter.shim_name) {
+		struct rtshim *shim = NULL;
+		if (tb[RTA_SHIM])
+			shim = RTA_DATA(tb[RTA_SHIM]);
+		if (shim && !strncmp(filter.shim_name, shim->name, SHIMNAMSIZ))
+			return 0;
+	}
 	if (filter.flushb &&
 	    r->rtm_family == AF_INET6 &&
 	    r->rtm_dst_len == 0 &&
@@ -288,7 +305,6 @@
 	    tb[RTA_PRIORITY] &&
 	    *(int*)RTA_DATA(tb[RTA_PRIORITY]) == -1)
 		return 0;
-
 	if (filter.flushb) {
 		struct nlmsghdr *fn;
 		if (NLMSG_ALIGN(filter.flushp) + n->nlmsg_len > filter.flushe) {
@@ -371,6 +387,22 @@
 	}
 	if (tb[RTA_OIF] && filter.oifmask != -1)
 		fprintf(fp, "dev %s ", ll_index_to_name(*(int*)RTA_DATA(tb[RTA_OIF])));
+	if (tb[RTA_SHIM]) {
+		struct rtshim *shim;
+
+		shim = RTA_DATA(tb[RTA_SHIM]);
+		if (!strncmp("mpls", shim->name, 4)) {
+			unsigned int key;
+			memcpy(&key, shim->data, 4);
+			fprintf(fp, "mpls 0x%x", key);
+		} else {
+			int i;
+			fprintf(fp, "shim %s 0x", shim->name);
+			for (i = 0;i < shim->datalen;i++) {
+				fprintf(fp, "%02x", shim->data[i]);
+			}
+		}
+	}
 
 	if (!(r->rtm_flags&RTM_F_CLONED)) {
 		if (table != RT_TABLE_MAIN && !filter.tb)
@@ -599,6 +631,39 @@
 	return 0;
 }
 
+#define SHIM_MAXSIZE 256
+int parse_shim(struct rtshim *shim, char *name, char *data)
+{
+        char str[(SHIM_MAXSIZE * 2) + 1];
+        int datalen = 0;
+        char hex[3];
+        int i, slen;
+
+        strncpy(shim->name, name, SHIMNAMSIZ);
+
+        if (strncmp(data, "0x", 2))
+                invarg("\"shim data\" value is invalid\n", data);
+
+        slen = strlen(data);
+        if (slen > ((SHIM_MAXSIZE * 2) + 2))
+                invarg("\"shim data\" value is too long\n", data);
+
+        if (slen & 1) {
+                str[0] = '0';
+                strcpy(&str[1], &data[2]);
+        } else {
+                strcpy(str, &data[2]);
+        }
+
+        slen = strlen(str);
+        for (i = 0;i < slen;i += 2) {
+                strncpy(hex, &str[i], 2);
+                shim->data[datalen++] = strtoul(hex, NULL, 16);
+        }
+        shim->datalen = datalen;
+
+	return datalen;
+}
 
 int parse_one_nh(struct rtattr *rta, struct rtnexthop *rtnh, int *argcp, char ***argvp)
 {
@@ -631,6 +696,41 @@
 				invarg("\"realm\" value is invalid\n", *argv);
 			rta_addattr32(rta, 4096, RTA_FLOW, realm);
 			rtnh->rtnh_len += sizeof(struct rtattr) + 4;
+		} else if (strcmp(*argv, "mpls") == 0) {
+			char buf[sizeof(struct rtshim) + sizeof(unsigned int)];
+			struct rtshim *shim = (struct rtshim *)buf;
+			unsigned int key;
+
+			NEXT_ARG();
+			if (get_unsigned(&key, *argv, 0))
+				invarg("\"mpls key\" is invalid\n", *argv);
+
+			strcpy(shim->name, "mpls");
+			memcpy(shim->data, &key, sizeof(unsigned int));
+			shim->datalen = sizeof(unsigned int);
+
+			rta_addattr_l(rta, 4096, RTA_SHIM, shim,
+				sizeof(struct rtshim) + sizeof(unsigned int));
+			rtnh->rtnh_len += sizeof(struct rtattr) +
+				sizeof(struct rtshim) + sizeof(unsigned int);
+		} else if (strcmp(*argv, "shim") == 0) {
+			char buf[sizeof(struct rtshim) + SHIM_MAXSIZE];
+			struct rtshim *shim = (struct rtshim *)buf;
+			int datalen;
+			char *name;
+			char *data;
+
+			NEXT_ARG();
+			name = *argv;
+			NEXT_ARG();
+			data = *argv;
+
+			datalen = parse_shim(shim, name, data);
+
+			rta_addattr_l(rta, 4096, RTA_SHIM, shim,
+				sizeof(struct rtshim) + datalen);
+			rtnh->rtnh_len += sizeof(struct rtattr) +
+				sizeof(struct rtshim) + datalen;
 		} else
 			break;
 	}
@@ -724,6 +824,37 @@
 			if (req.r.rtm_family == AF_UNSPEC)
 				req.r.rtm_family = addr.family;
 			addattr_l(&req.n, sizeof(req), RTA_GATEWAY, &addr.data, addr.bytelen);
+		} else if (strcmp(*argv, "mpls") == 0) {
+			char buf[sizeof(struct rtshim) + sizeof(unsigned int)];
+			struct rtshim *shim = (struct rtshim *)buf;
+			unsigned int key;
+
+			NEXT_ARG();
+			if (get_unsigned(&key, *argv, 0))
+				invarg("\"mpls key\" is invalid\n", *argv);
+
+			strcpy(shim->name, "mpls");
+			memcpy(shim->data, &key, sizeof(unsigned int));
+			shim->datalen = sizeof(unsigned int);
+
+			addattr_l(&req.n, sizeof(req), RTA_SHIM, shim,
+				sizeof(struct rtshim) + sizeof(unsigned int));
+		} else if (strcmp(*argv, "shim") == 0) {
+			char buf[sizeof(struct rtshim) + SHIM_MAXSIZE];
+			struct rtshim *shim = (struct rtshim *)buf;
+			int datalen;
+			char *name;
+			char *data;
+
+			NEXT_ARG();
+			name = *argv;
+			NEXT_ARG();
+			data = *argv;
+
+			datalen = parse_shim(shim, name, data);
+
+			addattr_l(&req.n, sizeof(req), RTA_SHIM, shim,
+				sizeof(struct rtshim) + datalen);
 		} else if (strcmp(*argv, "from") == 0) {
 			inet_prefix addr;
 			NEXT_ARG();
@@ -1113,6 +1244,15 @@
 		} else if (strcmp(*argv, "src") == 0) {
 			NEXT_ARG();
 			get_prefix(&filter.rprefsrc, *argv, do_ipv6);
+		} else if (matches(*argv, "mpls") == 0) {
+			unsigned int key;
+			NEXT_ARG();
+			if (get_unsigned(&key, *argv, 0))
+				invarg("\"mpls key\" is invalid\n", *argv);
+			filter.mpls = key;
+		} else if (matches(*argv, "shim") == 0) {
+			NEXT_ARG();
+			filter.shim_name = *argv;
 		} else if (matches(*argv, "realms") == 0) {
 			__u32 realm;
 			NEXT_ARG();
@@ -1320,6 +1460,38 @@
 			   strcmp(*argv, "dev") == 0) {
 			NEXT_ARG();
 			odev = *argv;
+		} else if (matches(*argv, "mpls") == 0) {
+			char buf[sizeof(struct rtshim) + sizeof(unsigned int)];
+			struct rtshim *shim = (struct rtshim *)buf;
+			unsigned int key;
+
+			NEXT_ARG();
+			if (get_unsigned(&key, *argv, 0))
+				invarg("\"mpls key\" is invalid\n", *argv);
+
+			strcpy(shim->name, "mpls");
+			memcpy(shim->data, &key, sizeof(unsigned int));
+			shim->datalen = sizeof(unsigned int);
+
+			addattr_l(&req.n, sizeof(req), RTA_SHIM, shim,
+				sizeof(struct rtshim) + sizeof(unsigned int));
+		} else if (matches(*argv, "shim") == 0) {
+			char buf[sizeof(struct rtshim) + SHIM_MAXSIZE];
+			struct rtshim *shim = (struct rtshim *)buf;
+			int datalen;
+			char *name;
+			char *data;
+
+			NEXT_ARG();
+			name = *argv;
+			NEXT_ARG();
+			data = *argv;
+
+			datalen = parse_shim(shim, name, data);
+
+			addattr_l(&req.n, sizeof(req), RTA_SHIM, shim,
+				sizeof(struct rtshim) + datalen);
+
 		} else if (matches(*argv, "notify") == 0) {
 			req.r.rtm_flags |= RTM_F_NOTIFY;
 		} else if (matches(*argv, "connected") == 0) {
@@ -1404,6 +1576,8 @@
 		}
 		if (!odev && tb[RTA_OIF])
 			tb[RTA_OIF]->rta_type = 0;
+		if (tb[RTA_SHIM])
+			tb[RTA_SHIM]->rta_type = 0;
 		if (tb[RTA_GATEWAY])
 			tb[RTA_GATEWAY]->rta_type = 0;
 		if (!idev && tb[RTA_IIF])
@@ -1468,4 +1642,3 @@
 	fprintf(stderr, "Command \"%s\" is unknown, try \"ip route help\".\n", *argv);
 	exit(-1);
 }
-
diff -Naur iproute2-2.6.22-070710/lib/ll_proto.c iproute2-mpls-1.1/lib/ll_proto.c
--- iproute2-2.6.22-070710/lib/ll_proto.c	2007-07-11 03:34:14.000000000 +0200
+++ iproute2-mpls-1.1/lib/ll_proto.c	2008-10-07 14:40:30.000000000 +0200
@@ -92,6 +92,7 @@
 #ifdef ETH_P_ECONET
 __PF(ECONET,econet)
 #endif
+__PF(MPLS_UC,mpls)
 
 { 0x8100, "802.1Q" },
 { ETH_P_IP, "ipv4" },
diff -Naur iproute2-2.6.22-070710/lib/utils.c iproute2-mpls-1.1/lib/utils.c
--- iproute2-2.6.22-070710/lib/utils.c	2007-07-11 03:34:14.000000000 +0200
+++ iproute2-mpls-1.1/lib/utils.c	2008-10-07 14:40:30.000000000 +0200
@@ -439,7 +439,7 @@
 		len = 4;
 	}
 
-	hash = addr[len-1] ^ addr[len-2] ^ addr[len-3] ^ addr[len-4];
+	hash = (addr[len-1] ^ addr[len-2] ^ addr[len-3] ^ addr[len-4]) & 0xff;
 
 	for (n = nht[hash]; n; n = n->next) {
 		if (n->addr.family == af &&
diff -Naur iproute2-2.6.22-070710/Makefile iproute2-mpls-1.1/Makefile
--- iproute2-2.6.22-070710/Makefile	2007-07-11 03:34:14.000000000 +0200
+++ iproute2-mpls-1.1/Makefile	2008-10-07 14:40:28.000000000 +0200
@@ -3,6 +3,7 @@
 CONFDIR=/etc/iproute2
 DOCDIR=/usr/share/doc/iproute2
 MANDIR=/usr/share/man
+KERNEL_INCLUDE=/usr/include
 
 # Path to db_185.h include
 DBM_INCLUDE:=/usr/include
@@ -21,13 +22,13 @@
 
 CC = gcc
 HOSTCC = gcc
-CCOPTS = -D_GNU_SOURCE -O2 -Wstrict-prototypes -Wall
+CCOPTS = -D_GNU_SOURCE -O2 -Wstrict-prototypes -Wall $(RPM_OPT_FLAGS)
 CFLAGS = $(CCOPTS) -I../include $(DEFINES)
 YACCFLAGS = -d -t -v
 
 LDLIBS += -L../lib -lnetlink -lutil
 
-SUBDIRS=lib ip tc misc netem genl
+SUBDIRS=lib ip tc misc netem genl mpls
 
 LIBNETLINK=../lib/libnetlink.a ../lib/libutil.a
 
diff -Naur iproute2-2.6.22-070710/man/man8/ip.8 iproute2-mpls-1.1/man/man8/ip.8
--- iproute2-2.6.22-070710/man/man8/ip.8	2007-07-11 03:34:14.000000000 +0200
+++ iproute2-mpls-1.1/man/man8/ip.8	2008-10-07 14:40:30.000000000 +0200
@@ -176,6 +176,8 @@
 .IR NUMBER " ] [ "
 .B  cwnd
 .IR NUMBER " ] [ "
+.B  initcwnd
+.IR NUMBER " ] [ "
 .B  ssthresh
 .IR REALM " ] [ "
 .B  realms
@@ -1080,6 +1082,11 @@
 flag is not used.
 
 .TP
+.BI initcwnd " NUMBER " 
+The maximum initial congestion window (cwnd) size in MSS of a
+TCP connection.
+
+.TP
 .BI advmss " NUMBER " "(2.3.15+ only)"
 the MSS ('Maximal Segment Size') to advertise to these
 destinations when establishing TCP connections.  If it is not given,
diff -Naur iproute2-2.6.22-070710/mpls/Makefile iproute2-mpls-1.1/mpls/Makefile
--- iproute2-2.6.22-070710/mpls/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ iproute2-mpls-1.1/mpls/Makefile	2008-10-07 14:40:31.000000000 +0200
@@ -0,0 +1,19 @@
+MPLSOBJ=mpls.o mpls_monitor.o
+
+include ../Config
+
+MPLSMODULES :=
+
+MPLSLIB := 
+
+LDFLAGS += -Wl,-export-dynamic -lm
+
+all: mpls 
+
+mpls: $(MPLSOBJ) $(LIBNETLINK) $(LIBUTIL) $(MPLSLIB) 
+
+install: all
+	install -m 0755 -s mpls $(DESTDIR)$(SBINDIR)
+
+clean:
+	rm -f $(MPLSOBJ) $(MPLSLIB) mpls
diff -Naur iproute2-2.6.22-070710/mpls/mpls.c iproute2-mpls-1.1/mpls/mpls.c
--- iproute2-2.6.22-070710/mpls/mpls.c	1970-01-01 01:00:00.000000000 +0100
+++ iproute2-mpls-1.1/mpls/mpls.c	2008-10-07 14:40:31.000000000 +0200
@@ -0,0 +1,1312 @@
+/*
+ * mpls.c		"mpls" utility frontend.
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <dlfcn.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <string.h>
+#include <errno.h>
+#include <math.h>
+#include <asm/types.h>
+#include <linux/if_ether.h>
+#include <linux/gen_stats.h>
+#include <linux/mpls.h>
+#include <linux/ip.h>
+#include <linux/if_tunnel.h>
+#include <sys/ioctl.h>
+#include <linux/genetlink.h>
+
+#include "SNAPSHOT.h"
+#include "utils.h"
+
+int show_stats = 0;
+int show_details = 0;
+int show_raw = 0;
+int resolve_hosts = 0;
+
+struct rtnl_handle rth1;	/* RTNL for NHLFE Adds */
+struct rtnl_handle rth2;	/* RTNL for all other MPLS entity actions */
+
+extern int do_mplsmonitor(int argc, char **argv);
+int print_mpls(const struct sockaddr_nl *who, struct nlmsghdr *n, void *arg);
+int print_tunnel(const struct mpls_tunnel_req *mtr, void *arg);
+
+static void usage(void)
+{
+	fprintf(stderr, "Usage: mpls ilm CMD label LABEL labelspace NUMBER [proto PROTO | instructions INSTR]\n");
+	fprintf(stderr, "       mpls nhlfe CMD key KEY [mtu MTU propagate_ttl | instructions INSTR]\n");
+	fprintf(stderr, "       mpls xc CMD ilm_label LABEL ilm_labelspace NUMBER nhlfe_key KEY\n");
+	fprintf(stderr, "       mpls labelspace set dev NAME labelspace NUMBER\n");
+	fprintf(stderr, "       mpls labelspace set dev NAME labelspace -1\n");
+	fprintf(stderr, "       mpls tunnel CMD dev NAME nhlfe KEY\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "       mpls ilm show [label LABEL labelspace NUMBER]\n");
+	fprintf(stderr, "       mpls nhlfe show [key KEY]\n");
+	fprintf(stderr, "       mpls xc show [ilm_label LABEL ilm_labelspace NUMBER]\n");
+	fprintf(stderr, "       mpls labelspace show [dev NAME]\n");
+	fprintf(stderr, "       mpls monitor ...\n");
+	fprintf(stderr, "\n");
+	fprintf(stderr, "Where:\n");
+	fprintf(stderr, "CMD    := add | del | change\n");
+	fprintf(stderr, "NUMBER := 0 .. 255\n");
+	fprintf(stderr, "TYPE   := gen | atm | fr\n");
+	fprintf(stderr, "VALUE  := 16 .. 1048575 | <VPI>/<VCI> | 16 .. 1023\n");
+	fprintf(stderr, "LABEL  := TYPE VALUE\n");
+	fprintf(stderr, "KEY    := 0 for add | previously returned key\n");
+	fprintf(stderr, "NAME   := network device name (i.e. eth0)\n");
+	fprintf(stderr, "PROTO  := ipv4 | ipv6\n");
+	fprintf(stderr, "ADDR   := ipv6 or ipv4 address\n");
+	fprintf(stderr, "NH     := nexthop NAME [none|packet|PROTO ADDR]\n");
+	fprintf(stderr, "FWD    := forward KEY\n");
+	fprintf(stderr, "PUSH   := push LABEL\n");
+	fprintf(stderr, "INSTR  := NH | PUSH | pop | deliver | peek | FWD |\n");
+	fprintf(stderr, "	  set-dscp <DSCP> | set-exp <EXP> |\n");
+	fprintf(stderr, "	  set-tcindex <TCINDEX> | set-rx-if <NAME>\n");
+	fprintf(stderr, "	  forward <KEY> | expfwd <EXP> <KEY> ... |\n");
+	fprintf(stderr, "	  exp2tc <EXP> <TCINDEX> ... | exp2ds <EXP> <DSCP> ... |\n");
+	fprintf(stderr, "	  nffwd <MASK> [ <NFMARK> <KEY> ... ] |\n");
+	fprintf(stderr, "	  nf2exp <MASK> [ <NFMARK> <EXP> ... ] |\n");
+	fprintf(stderr, "	  tc2exp <MASK> [ <TCINDEX> <EXP> ... ] |\n");
+	fprintf(stderr, "	  ds2exp <MASK> [ <DSCP> <EXP> ... ] |\n");
+	fprintf(stderr, "	  dsfwd <MASK> [ <DSCP> <KEY> ... ]\n");
+	fprintf(stderr, "\n");
+	exit(-1);
+}
+
+int mpls_list(int cmd,int argc, char **argv);
+
+int mpls_table_list(int argc, char **argv)
+{
+	if (argc <= 0) {
+		mpls_list(MPLS_CMD_GETNHLFE,0,NULL);
+		mpls_list(MPLS_CMD_GETILM,0,NULL);
+		mpls_list(MPLS_CMD_GETXC,0,NULL);
+		mpls_list(MPLS_CMD_GETLABELSPACE,0,NULL);
+	}
+	return 0;
+}
+
+void
+mpls_parse_label (struct mpls_label *label, int *pargc, char ***pargv) {
+	unsigned int l1, l2;
+	char *value;
+	int argc = *pargc;
+	char **argv = *pargv;
+
+	if (strncmp(*argv, "fr", 2) == 0) {
+		label->ml_type = MPLS_LABEL_FR;
+	} else if (strncmp(*argv, "atm", 3) == 0) {
+		label->ml_type = MPLS_LABEL_ATM;
+	} else if (strncmp(*argv, "gen", 3) == 0) {
+		label->ml_type = MPLS_LABEL_GEN;
+	} else {
+		invarg(*argv, "invalid mpls label type");
+	}
+
+	NEXT_ARG();
+	value = *argv;
+
+	switch (label->ml_type) {
+		case MPLS_LABEL_GEN:
+			if (get_unsigned(&l1, value, 0) || l1 > 1048575)
+				invarg(value, "invalid label value");
+			label->u.ml_gen = l1;
+			break;
+		case MPLS_LABEL_ATM:
+			if (sscanf(value, "%u/%d", &l1, &l2) != 2)
+				invarg(value, "invalid label value");
+			label->u.ml_atm.mla_vpi = l1;
+			label->u.ml_atm.mla_vci = l2;
+		case MPLS_LABEL_FR:
+			if (get_unsigned(&l1, value, 0) || l1 > 1023)
+				invarg(value, "invalid label value");
+			label->u.ml_fr = l1;
+		default:
+			fprintf(stderr, "Invalid label type!\n");
+			exit(-1);
+	}
+	*pargc = argc;
+	*pargv = argv;
+}
+
+void
+mpls_parse_instr(struct mpls_instr_req *instr, int *pargc, char ***pargv,
+	int direction) {
+	int argc = *pargc;
+	char **argv = *pargv;
+	int c = 0;
+
+	while (argc > 0) {
+		if (strcmp(*argv, "nexthop") == 0) {
+			NEXT_ARG();
+			inet_prefix addr;
+			instr->mir_instr[c].mir_opcode = MPLS_OP_SET;
+			instr->mir_instr[c].mir_set.mni_if =
+				ll_name_to_index(*argv);
+			NEXT_ARG();
+			if (strcmp(*argv, "ipv4") == 0) {
+				struct sockaddr_in *sin = (struct sockaddr_in*)
+					&instr->mir_instr[c].mir_set.mni_addr;
+				NEXT_ARG();
+				get_addr(&addr, *argv, AF_INET);
+				sin->sin_family = AF_INET;
+				memcpy(&sin->sin_addr, &addr.data,
+					addr.bytelen);
+			} else if (strcmp(*argv, "ipv6") == 0) {
+				struct sockaddr_in6 *sin6=(struct sockaddr_in6*)
+					&instr->mir_instr[c].mir_set.mni_addr;
+				NEXT_ARG();
+				get_addr(&addr, *argv, AF_INET6);
+				sin6->sin6_family = AF_INET6;
+				memcpy(&sin6->sin6_addr, &addr.data,
+					addr.bytelen);
+			} else if (strcmp(*argv, "packet") == 0) {
+				struct sockaddr *s =
+					&instr->mir_instr[c].mir_set.mni_addr;
+				s->sa_family = AF_PACKET;
+			} else if (strcmp(*argv, "none") == 0) {
+				struct sockaddr *s =
+					&instr->mir_instr[c].mir_set.mni_addr;
+				memset(s, 0, sizeof(struct sockaddr));
+				continue;
+			} else {
+				invarg(*argv, "invalid nexthop type");
+			}
+		} else if (strcmp(*argv, "push") == 0) {
+			NEXT_ARG();
+			instr->mir_instr[c].mir_opcode = MPLS_OP_PUSH;
+			*pargc = argc; *pargv = argv;
+			mpls_parse_label(&instr->mir_instr[c].mir_push,
+				pargc, pargv);
+			argc = *pargc; argv = *pargv;
+		} else if (strcmp(*argv, "forward") == 0) {
+			__u32 key;
+			NEXT_ARG();
+			if (get_unsigned(&key, *argv, 0))
+				invarg(*argv, "invalid key");
+			instr->mir_instr[c].mir_fwd.ml_type = MPLS_LABEL_KEY;
+			instr->mir_instr[c].mir_fwd.u.ml_key = key;
+			instr->mir_instr[c].mir_opcode = MPLS_OP_FWD;
+		} else if (strcmp(*argv, "pop") == 0) {
+			if (direction == MPLS_OUT)
+				invarg(*argv, "invalid NHLFE instruction");
+			instr->mir_instr[c].mir_opcode = MPLS_OP_POP;
+		} else if (strcmp(*argv, "peek") == 0) {
+			if (direction == MPLS_OUT)
+				invarg(*argv, "invalid NHLFE instruction");
+			instr->mir_instr[c].mir_opcode = MPLS_OP_PEEK;
+		} else if (strcmp(*argv, "deliver") == 0) {
+			if (direction == MPLS_OUT)
+				invarg(*argv, "invalid NHLFE instruction");
+			instr->mir_instr[c].mir_opcode = MPLS_OP_DLV;
+		} else if (strcmp(*argv, "set-dscp") == 0) {
+			__u32 dscp;
+			if (direction == MPLS_OUT)
+				invarg(*argv, "invalid NHLFE instruction");
+			NEXT_ARG();
+			if (get_unsigned(&dscp, *argv, 0))
+				invarg(*argv, "invalid DSCP");
+			instr->mir_instr[c].mir_opcode = MPLS_OP_SET_DS;
+			instr->mir_instr[c].mir_set_ds = dscp;
+		} else if (strcmp(*argv, "set-tcindex") == 0) {
+			__u32 tcindex;
+			NEXT_ARG();
+			if (get_unsigned(&tcindex, *argv, 0))
+				invarg(*argv, "invalid TCINDEX");
+			instr->mir_instr[c].mir_opcode = MPLS_OP_SET_TC;
+			instr->mir_instr[c].mir_set_tc = tcindex;
+		} else if (strcmp(*argv, "set-exp") == 0) {
+			__u32 exp;
+			NEXT_ARG();
+			if (get_unsigned(&exp, *argv, 0))
+				invarg(*argv, "invalid EXP");
+			instr->mir_instr[c].mir_opcode = MPLS_OP_SET_EXP;
+			instr->mir_instr[c].mir_set_exp = exp;
+		} else if (strcmp(*argv, "set-rx-if") == 0) {
+			if (direction == MPLS_OUT)
+				invarg(*argv, "invalid NHLFE instruction");
+			NEXT_ARG();
+			instr->mir_instr[c].mir_opcode = MPLS_OP_SET_RX;
+			instr->mir_instr[c].mir_set_rx =ll_name_to_index(*argv);
+		} else if (strcmp(*argv, "expfwd") == 0) {
+			int done = 0;
+			unsigned int exp;
+			unsigned int key;
+			do {
+				NEXT_ARG();
+				if (get_unsigned(&exp, *argv, 0)) {
+					done = 1;
+					break;
+				}
+				NEXT_ARG();
+				if (get_unsigned(&key, *argv, 0)) {
+					done = 1;
+					break;
+				}
+				instr->mir_instr[c].mir_exp_fwd.ef_key[exp] = key;
+			} while (!done);
+			PREV_ARG();
+			instr->mir_instr[c].mir_opcode = MPLS_OP_EXP_FWD;
+		} else if (strcmp(*argv, "exp2tc") == 0) {
+			int done = 0;
+			unsigned int exp;
+			unsigned int tcindex;
+			do {
+				NEXT_ARG();
+				if (get_unsigned(&exp, *argv, 0)) {
+					done = 1;
+					break;
+				}
+				NEXT_ARG();
+				if (get_unsigned(&tcindex, *argv, 0)) {
+					done = 1;
+					break;
+				}
+				instr->mir_instr[c].mir_exp2tc.e2t[exp] =
+									tcindex;
+			} while (!done);
+			PREV_ARG();
+			instr->mir_instr[c].mir_opcode = MPLS_OP_EXP2TC;
+		} else if (strcmp(*argv, "exp2ds") == 0) {
+			int done = 0;
+			unsigned int exp;
+			unsigned int dscp;
+			if (direction == MPLS_OUT)
+				invarg(*argv, "invalid NHLFE instruction");
+			do {
+				NEXT_ARG();
+				if (get_unsigned(&exp, *argv, 0)) {
+					done = 1;
+					break;
+				}
+				NEXT_ARG();
+				if (get_unsigned(&dscp, *argv, 0)) {
+					done = 1;
+					break;
+				}
+				instr->mir_instr[c].mir_exp2ds.e2d[exp] = dscp;
+			} while (!done);
+			PREV_ARG();
+			instr->mir_instr[c].mir_opcode = MPLS_OP_EXP2DS;
+		} else if (strcmp(*argv, "nffwd") == 0) {
+			int done = 0;
+			unsigned int nfmark;
+			unsigned int key;
+			unsigned int mask;
+			NEXT_ARG();
+			if (!get_unsigned(&mask, *argv, 0)) {
+				instr->mir_instr[c].mir_nf_fwd.nf_mask = mask;
+				do {
+					NEXT_ARG();
+					if (get_unsigned(&nfmark, *argv, 0)) {
+						done = 1;
+						break;
+					}
+					NEXT_ARG();
+					if (get_unsigned(&key, *argv, 0)) {
+						done = 1;
+						break;
+					}
+					instr->mir_instr[c].mir_nf_fwd.nf_key[nfmark] = key;
+				} while (!done);
+			}
+			PREV_ARG();
+			instr->mir_instr[c].mir_opcode = MPLS_OP_NF_FWD;
+		} else if (strcmp(*argv, "nf2exp") == 0) {
+			int done = 0;
+			unsigned int nfmark;
+			unsigned int exp;
+			unsigned int mask;
+			NEXT_ARG();
+			if (!get_unsigned(&mask, *argv, 0)) {
+				instr->mir_instr[c].mir_nf2exp.n2e_mask = mask;
+				do {
+					NEXT_ARG();
+					if (get_unsigned(&nfmark, *argv, 0)) {
+						done = 1;
+						break;
+					}
+					NEXT_ARG();
+					if (get_unsigned(&exp, *argv, 0)) {
+						done = 1;
+						break;
+					}
+					instr->mir_instr[c].mir_nf2exp.n2e[nfmark] = exp;
+				} while (!done);
+			}
+			PREV_ARG();
+			instr->mir_instr[c].mir_opcode = MPLS_OP_NF2EXP;
+		} else if (strcmp(*argv, "tc2exp") == 0) {
+			int done = 0;
+			unsigned int tcindex;
+			unsigned int exp;
+			unsigned int mask;
+			NEXT_ARG();
+			if (!get_unsigned(&mask, *argv, 0)) {
+				instr->mir_instr[c].mir_tc2exp.t2e_mask = mask;
+				do {
+					NEXT_ARG();
+					if (get_unsigned(&tcindex, *argv, 0)) {
+						done = 1;
+						break;
+					}
+					NEXT_ARG();
+					if (get_unsigned(&exp, *argv, 0)) {
+						done = 1;
+						break;
+					}
+					instr->mir_instr[c].mir_tc2exp.t2e[tcindex] = exp;
+				} while (!done);
+			}
+			PREV_ARG();
+			instr->mir_instr[c].mir_opcode = MPLS_OP_TC2EXP;
+		} else if (strcmp(*argv, "ds2exp") == 0) {
+			int done = 0;
+			unsigned int dscp;
+			unsigned int exp;
+			unsigned int mask;
+			if (direction == MPLS_IN)
+				invarg(*argv, "invalid ILM instruction");
+			NEXT_ARG();
+			if (!get_unsigned(&mask, *argv, 0)) {
+				instr->mir_instr[c].mir_ds2exp.d2e_mask = mask;
+				do {
+					NEXT_ARG();
+					if (get_unsigned(&dscp, *argv, 0)) {
+						done = 1;
+						break;
+					}
+					NEXT_ARG();
+					if (get_unsigned(&exp, *argv, 0)) {
+						done = 1;
+						break;
+					}
+					instr->mir_instr[c].mir_ds2exp.d2e[dscp] = exp;
+				} while (!done);
+			}
+			PREV_ARG();
+			instr->mir_instr[c].mir_opcode = MPLS_OP_DS2EXP;
+		} else if (strcmp(*argv, "dsfwd") == 0) {
+			int done = 0;
+			unsigned int dscp;
+			unsigned int key;
+			unsigned int mask;
+			NEXT_ARG();
+			if (!get_unsigned(&mask, *argv, 0)) {
+				instr->mir_instr[c].mir_ds_fwd.df_mask = mask;
+				do {
+					NEXT_ARG();
+					if (get_unsigned(&dscp, *argv, 0)) {
+						done = 1;
+						break;
+					}
+					NEXT_ARG();
+					if (get_unsigned(&key, *argv, 0)) {
+						done = 1;
+						break;
+					}
+					instr->mir_instr[c].mir_ds_fwd.df_key[dscp] = key;
+				} while (!done);
+			}
+			PREV_ARG();
+			instr->mir_instr[c].mir_opcode = MPLS_OP_DS_FWD;
+		} else {
+			invarg(*argv, "invalid mpls instruction");
+		}
+		argc--; argv++; c++;
+	}
+	instr->mir_instr_length = c;
+	instr->mir_direction = direction;
+
+	*pargc = argc;
+	*pargv = argv;
+}
+
+int
+mpls_ilm_modify(int cmd, unsigned flags, int argc, char **argv)
+{
+	struct genlmsghdr		*ghdr;
+	struct {
+		struct nlmsghdr		n;
+		char			buf[4096];
+	} req;
+	struct mpls_in_label_req	mil;
+	struct mpls_instr_req		instr;
+
+	memset(&req, 0, sizeof(req));
+	memset(&mil, 0, sizeof(mil));
+	memset(&instr, 0, sizeof(instr));
+
+	req.n.nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);
+	req.n.nlmsg_flags = NLM_F_REQUEST|flags;
+	req.n.nlmsg_type = PF_MPLS;
+
+	ghdr = NLMSG_DATA(&req.n);
+	ghdr->cmd = cmd;
+
+	mil.mil_proto = AF_INET;
+
+	while (argc > 0) {
+		if (strcmp(*argv, "labelspace") == 0) {
+			__u32 ls;
+			NEXT_ARG();
+			if (get_unsigned(&ls, *argv, 0) || ls > 255)
+				invarg(*argv, "invalid labelspace");
+			mil.mil_label.ml_index = ls;
+		} else if (strcmp(*argv, "label") == 0) {
+			NEXT_ARG();
+			mpls_parse_label(&mil.mil_label, &argc, &argv);
+		} else if (strcmp(*argv, "proto") == 0) {
+			NEXT_ARG();
+			if (strncmp(*argv, "ipv4", 4) == 0) {
+				mil.mil_proto = AF_INET;
+			} else if (strncmp(*argv, "ipv6", 4) == 0) {
+				mil.mil_proto = AF_INET6;
+			} else if (strncmp(*argv, "packet", 6) == 0) {
+				mil.mil_proto = AF_PACKET;
+			} else {
+				invarg(*argv, "invalid ilm proto");
+			}
+			mil.mil_change_flag |= MPLS_CHANGE_PROTO;
+		} else if (strcmp(*argv, "instructions") == 0) {
+			NEXT_ARG();
+			mpls_parse_instr(&instr, &argc, &argv, MPLS_IN);
+			mil.mil_change_flag |= MPLS_CHANGE_INSTR;
+		} else {
+			invarg(*argv, "invalid ilm argument");
+		}
+		argc--; argv++;
+	}
+
+	if (!mil.mil_label.ml_type) {
+		fprintf(stderr, "you must specify a label value\n");
+		exit(1);
+	}
+
+	addattr_l(&req.n, sizeof(req), MPLS_ATTR_ILM, &mil, sizeof(mil));
+	addattr_l(&req.n, sizeof(req), MPLS_ATTR_INSTR, &instr, sizeof(instr));
+
+	if (rtnl_talk(&rth2, &req.n, 0, 0, NULL, NULL, NULL) < 0)
+		exit(2);
+
+	return 0;
+}
+
+int
+mpls_nhlfe_modify(int cmd, unsigned flags, int argc, char **argv)
+{
+	struct genlmsghdr		*ghdr;
+	struct {
+		struct nlmsghdr		n;
+		char			buf[4096];
+	} req;
+	struct mpls_out_label_req 	mol;
+	struct mpls_instr_req 		instr;
+
+	memset(&req, 0, sizeof(req));
+	memset(&mol, 0, sizeof(mol));
+	memset(&instr, 0, sizeof(instr));
+
+	req.n.nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);
+	req.n.nlmsg_flags = NLM_F_REQUEST|flags;
+	req.n.nlmsg_type = PF_MPLS;
+
+	ghdr = NLMSG_DATA(&req.n);
+	ghdr->cmd = cmd;
+
+	while (argc > 0) {
+		if (strcmp(*argv, "key") == 0) {
+			__u32 key;
+			NEXT_ARG();
+			if (get_unsigned(&key, *argv, 0))
+				invarg(*argv, "invalid key");
+			mol.mol_label.u.ml_key = key;
+			mol.mol_label.ml_type = MPLS_LABEL_KEY;
+		} else if (strcmp(*argv, "mtu") == 0) {
+			__u32 mtu;
+			NEXT_ARG();
+			if (get_unsigned(&mtu, *argv, 0))
+				invarg(*argv, "invalid mtu");
+			mol.mol_mtu = mtu;
+			mol.mol_change_flag |= MPLS_CHANGE_MTU;
+		} else if (strcmp(*argv, "no_propagate_ttl") == 0) {
+			mol.mol_propagate_ttl = 0;
+			mol.mol_change_flag |= MPLS_CHANGE_PROP_TTL;
+		} else if (strcmp(*argv, "propagate_ttl") == 0) {
+			mol.mol_propagate_ttl = 1;
+			mol.mol_change_flag |= MPLS_CHANGE_PROP_TTL;
+		} else if (strcmp(*argv, "instructions") == 0) {
+			NEXT_ARG();
+			mpls_parse_instr(&instr, &argc, &argv, MPLS_OUT);
+			mol.mol_change_flag |= MPLS_CHANGE_INSTR;
+		} else {
+			usage();
+		}
+		argc--; argv++;
+	}
+
+	addattr_l(&req.n, sizeof(req), MPLS_ATTR_NHLFE, &mol, sizeof(mol));
+	addattr_l(&req.n, sizeof(req), MPLS_ATTR_INSTR, &instr, sizeof(instr));
+
+	if (flags & NLM_F_CREATE) {
+		if (rtnl_talk(&rth1, &req.n, 0, 0, &req.n, NULL, NULL) < 0)
+			exit(2);
+
+		print_mpls(NULL, &req.n, stdout);
+	} else {
+		if (rtnl_talk(&rth2, &req.n, 0, 0, NULL, NULL, NULL) < 0)
+			exit(2);
+	}
+
+	return 0;
+}
+
+int
+mpls_xc_modify(int cmd, unsigned flags, int argc, char **argv)
+{
+	struct genlmsghdr		*ghdr;
+	struct {
+		struct nlmsghdr 	n;
+		char			buf[4096];
+	} req;
+	struct mpls_xconnect_req	xc;
+
+	memset(&req, 0, sizeof(req));
+	memset(&xc, 0, sizeof(xc));
+
+	req.n.nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);
+	req.n.nlmsg_flags = NLM_F_REQUEST|flags;
+	req.n.nlmsg_type = PF_MPLS;
+
+	ghdr = NLMSG_DATA(&req.n);
+	ghdr->cmd = cmd;
+
+	while (argc > 0) {
+
+		if (strcmp(*argv, "ilm_labelspace") == 0) {
+			__u32 ls;
+			NEXT_ARG();
+			if (get_unsigned(&ls, *argv, 0) || ls > 255)
+				invarg(*argv, "invalid labelspace");
+			xc.mx_in.ml_index = ls;
+		} else if (strcmp(*argv, "ilm_label") == 0) {
+			NEXT_ARG();
+			mpls_parse_label(&xc.mx_in, &argc, &argv);
+		} else if (strcmp(*argv, "nhlfe_key") == 0) {
+			__u32 key;
+			NEXT_ARG();
+			if (get_unsigned(&key, *argv, 0))
+				invarg(*argv, "invalid key");
+			xc.mx_out.u.ml_key = key;
+			xc.mx_out.ml_type = MPLS_LABEL_KEY;
+		} else {
+			usage();
+		}
+		argc--; argv++;
+	}
+
+	if (!xc.mx_in.ml_type) {
+		fprintf(stderr, "you must specify a ILM label value\n");
+		exit(1);
+	}
+
+	if (!xc.mx_out.u.ml_key) {
+		fprintf(stderr, "you must specify a NHLFE key\n");
+		exit(1);
+	}
+
+	addattr_l(&req.n, sizeof(req), MPLS_ATTR_XC, &xc, sizeof(xc));
+
+	if (rtnl_talk(&rth2, &req.n, 0, 0, NULL, NULL, NULL) < 0)
+		exit(2);
+
+	return 0;
+}
+
+int
+mpls_labelspace_modify(int cmd, unsigned flags, int argc, char **argv)
+{
+	__u32 labelspace = -2;
+	struct genlmsghdr		*ghdr;
+	struct {
+		struct nlmsghdr 	n;
+		char			buf[4096];
+	} req;
+	struct mpls_labelspace_req 	ls;
+
+	memset(&req, 0, sizeof(req));
+	memset(&ls, 0, sizeof(ls));
+
+	req.n.nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);
+	req.n.nlmsg_flags = NLM_F_REQUEST|flags;
+	req.n.nlmsg_type = PF_MPLS;
+
+	ghdr = NLMSG_DATA(&req.n);
+	ghdr->cmd = cmd;
+
+	while (argc > 0) {
+		if (strcmp(*argv, "dev") == 0) {
+			NEXT_ARG();
+			ls.mls_ifindex = ll_name_to_index(*argv);
+		} else if (strcmp(*argv, "labelspace") == 0) {
+			NEXT_ARG();
+			if (get_unsigned(&labelspace, *argv, 0))
+				invarg(*argv, "invalid labelspace");
+			ls.mls_labelspace = labelspace;
+		} else {
+			usage();
+		}
+		argc--; argv++;
+	}
+
+	if (ls.mls_ifindex == 0 || ls.mls_labelspace == -2) {
+		fprintf(stderr, "Invalid arguments\n");
+		exit(1);
+	}
+
+	addattr_l(&req.n, sizeof(req), MPLS_ATTR_LABELSPACE, &ls, sizeof(ls));
+
+	if (rtnl_talk(&rth2, &req.n, 0, 0, NULL, NULL, NULL) < 0)
+		exit(2);
+
+	return 0;
+}
+
+int
+mpls_tunnel_modify(int cmd, int argc, char **argv)
+{
+	unsigned int key = -2;
+	struct ifreq ifr;
+	struct mpls_tunnel_req mtr;
+	int err;
+	int fd;
+
+	memset(&ifr, 0, sizeof(ifr));
+	memset(&mtr, 0, sizeof(mtr));
+
+	while (argc > 0) {
+		if (strcmp(*argv, "dev") == 0) {
+			NEXT_ARG();
+			strcpy(ifr.ifr_name, "mpls0");
+			strncpy(mtr.mt_ifname, *argv, IFNAMSIZ);
+		} else if (strcmp(*argv, "nhlfe") == 0) {
+			NEXT_ARG();
+			if (get_unsigned(&key, *argv, 0))
+				invarg(*argv, "invalid NHLFE key");
+			mtr.mt_nhlfe_key = key;
+		} else {
+			usage();
+		}
+		argc--; argv++;
+	}
+
+	if (!strlen(mtr.mt_ifname)) {
+		fprintf(stderr, "You must specify a interface name\n");
+		exit(1);
+	}
+
+	fd = socket(AF_INET, SOCK_DGRAM, 0);
+	ifr.ifr_data = (void*)&mtr;
+	err = ioctl(fd, cmd, &ifr);
+	
+	if (err)
+		perror("ioctl");
+	else
+		print_tunnel(&mtr, stdout);
+
+	return 0;
+}
+
+void print_mpls_stats(FILE *fp, struct gnet_stats_basic *st)
+{
+	fprintf(fp, " (%llu bytes, %u pkts)",
+		(unsigned long long)st->bytes, st->packets);
+}
+
+void print_address(FILE *fp, struct sockaddr *addr) {
+	char buf[256];
+	switch (addr->sa_family) {
+		case AF_INET:
+		{
+			struct sockaddr_in *sin = (struct sockaddr_in*)addr;
+			inet_ntop(addr->sa_family, &sin->sin_addr,
+				buf, sizeof(buf));
+			fprintf(fp, "ipv4 %s ", buf);
+			break;
+		}
+		case AF_INET6:
+		{
+			struct sockaddr_in6 *sin6 = (struct sockaddr_in6*)addr;
+			inet_ntop(addr->sa_family, &sin6->sin6_addr,
+				buf, sizeof(buf));
+			fprintf(fp, "ipv6 %s ", buf);
+			break;
+		}
+		case AF_PACKET:
+		{
+			fprintf(fp, "packet");
+			break;
+		}
+		default:
+			fprintf(fp, "<unknown address family %d> ",
+				addr->sa_family);
+	}
+}
+
+void print_label(FILE *fp, struct mpls_label *label) {
+	switch (label->ml_type) {
+		case MPLS_LABEL_GEN:
+			fprintf(fp, "gen %d ", label->u.ml_gen);
+			break;
+		case MPLS_LABEL_ATM:
+			fprintf(fp, "atm %d/%d ", label->u.ml_atm.mla_vpi,
+				label->u.ml_atm.mla_vci);
+			break;
+		case MPLS_LABEL_FR:
+			fprintf(fp, "fr %d ", label->u.ml_fr);
+			break;
+		case MPLS_LABEL_KEY:
+			fprintf(fp, "key 0x%08x ", label->u.ml_key);
+			break;
+		default:
+			fprintf(fp, "<unknown label type %d> ", label->ml_type);
+	}
+}
+
+void print_instructions(FILE *fp, struct mpls_instr_req *instr) 
+{
+	struct mpls_instr_elem *ci;   /* current instruction */
+	unsigned int key;
+	int i,j;
+
+	for(i = 0;i < instr->mir_instr_length;i++) {
+		ci = &instr->mir_instr[i];
+
+		switch (ci->mir_opcode) {
+			case MPLS_OP_NOP:
+				fprintf(fp, "noop ");
+				break;
+			case MPLS_OP_POP:
+				fprintf(fp, "pop ");
+				break;
+			case MPLS_OP_PEEK:
+				fprintf(fp, "peek ");
+				break;
+			case MPLS_OP_PUSH:
+				fprintf(fp, "push ");
+				print_label(fp, &ci->mir_push);
+				break;
+			case MPLS_OP_FWD:
+				fprintf(fp, "forward ");
+				print_label(fp, &ci->mir_fwd);
+				break;
+			case MPLS_OP_DLV:
+				fprintf(fp, "deliver ");
+				break;
+			case MPLS_OP_SET:
+				fprintf(fp, "set %s ",
+					ll_index_to_name(ci->mir_set.mni_if));
+				print_address(fp, &ci->mir_set.mni_addr);
+				break;				
+			case MPLS_OP_SET_RX:
+				fprintf(fp, "set-rx-if %s ",
+					ll_index_to_name(ci->mir_set_rx));
+				break;
+			case MPLS_OP_SET_TC:
+				fprintf(fp, "set-tcindex %hu ",ci->mir_set_tc);
+				break;
+			case MPLS_OP_SET_DS:
+				fprintf(fp, "set-dscp %hu ",ci->mir_set_ds);
+				break;
+			case MPLS_OP_SET_EXP:
+				fprintf(fp, "set-exp %hhu ",ci->mir_set_exp);
+				break;	
+			case MPLS_OP_NF_FWD:
+				fprintf(fp, "nffwd 0x%2.2hhx ",
+					ci->mir_nf_fwd.nf_mask);
+
+				for(j=0;j<MPLS_NFMARK_NUM;j++) {
+					key = ci->mir_nf_fwd.nf_key[j];
+					if (key) fprintf(fp,"%d %8.8x ",j,key);
+				}
+				break;
+			case MPLS_OP_DS_FWD:
+				fprintf(fp, "dsfwd 0x%2.2hhx ",
+					ci->mir_ds_fwd.df_mask);
+
+				for(j=0;j<MPLS_DSMARK_NUM;j++) {
+					key = ci->mir_ds_fwd.df_key[j];
+					if (key) fprintf(fp,"%d %8.8x ",j,key);
+				}
+				break;
+			case MPLS_OP_EXP_FWD:
+				fprintf(fp, "exp-fwd ");
+
+				for(j=0;j<MPLS_EXP_NUM;j++) {
+					key = ci->mir_exp_fwd.ef_key[j];
+					if (key) fprintf(fp,"%d %8.8x ",j,key);
+				}
+				break;
+			case MPLS_OP_EXP2TC:
+				fprintf(fp, "exp2tc ");
+
+				for(j=0;j<MPLS_EXP_NUM;j++) {
+					fprintf(fp,"%d %hu ",
+						j,ci->mir_exp2tc.e2t[j]);
+
+				}
+				break;
+			case MPLS_OP_EXP2DS:
+				fprintf(fp, "exp2ds ");
+
+				for(j=0;j<MPLS_EXP_NUM;j++) {
+					fprintf(fp,"%d %hhu ",
+						j,ci->mir_exp2ds.e2d[j]);
+				}
+				break;
+			case MPLS_OP_TC2EXP:
+				fprintf(fp, "tc2exp 0x%2.2hhx ",
+					ci->mir_tc2exp.t2e_mask);
+
+				for(j=0;j<MPLS_TCINDEX_NUM;j++) {
+					fprintf(fp,"%d %hhu ",
+						j,ci->mir_tc2exp.t2e[j]);
+
+				}
+				break;
+			case MPLS_OP_DS2EXP:
+				fprintf(fp, "ds2exp 0x%2.2hhx ",
+					ci->mir_ds2exp.d2e_mask);
+
+				for(j=0;j<MPLS_DSMARK_NUM;j++) {
+					fprintf(fp,"%d %hhu ",
+						j,ci->mir_ds2exp.d2e[j]);
+
+				}
+				break;
+			case MPLS_OP_NF2EXP:
+				fprintf(fp, "nf2exp 0x%2.2hhx ",
+					ci->mir_nf2exp.n2e_mask);
+
+				for(j=0;j<MPLS_NFMARK_NUM;j++) {
+					fprintf(fp,"%d %hhu ",
+						j,ci->mir_nf2exp.n2e[j]);
+
+				}
+				break;	
+			default:
+				fprintf(fp, "<unknown opcode %d> ", 
+					ci->mir_opcode);
+		}
+	}
+}
+
+int print_ilm(int cmd, const struct nlmsghdr *n, void *arg, struct rtattr **tb)
+{
+	FILE *fp = (FILE*)arg;
+	struct mpls_in_label_req *mil;
+	struct mpls_instr_req *instr;
+	struct gnet_stats_basic *stats;
+
+	if (cmd == MPLS_CMD_DELILM)
+		fprintf(fp, "deleted ILM entry ");
+
+	if (cmd == MPLS_CMD_NEWILM)
+		fprintf(fp, "ILM entry ");
+
+	mil = RTA_DATA(tb[MPLS_ATTR_ILM]);
+	instr = RTA_DATA(tb[MPLS_ATTR_INSTR]);
+	stats = RTA_DATA(tb[MPLS_ATTR_STATS]);
+
+	fprintf(fp, "label ");
+	print_label(fp, &mil->mil_label);
+
+	fprintf(fp, "labelspace %d ", mil->mil_label.ml_index);
+
+	switch(mil->mil_proto) {
+		case AF_INET:
+			fprintf(fp, "proto ipv4 ");
+			break;
+		case AF_INET6:
+			fprintf(fp, "proto ipv6 ");
+			break;
+		case AF_PACKET:
+			fprintf(fp, "proto packet ");
+			break;
+		default:
+			fprintf(fp, "<unknown proto %d> ", mil->mil_proto);
+	}
+
+	fprintf(fp, "\n\t");
+	if (instr && instr->mir_instr_length) {
+		print_instructions(fp, instr);
+	}
+
+	if (stats)
+		print_mpls_stats(fp, stats);
+
+	fprintf(fp, "\n");
+	fflush(fp);
+	return 0;
+}
+
+int print_xc(int cmd, const struct nlmsghdr *n, void *arg, struct rtattr **tb)
+{
+	FILE *fp = (FILE*)arg;
+	struct mpls_xconnect_req *xc;
+
+	xc = RTA_DATA(tb[MPLS_ATTR_XC]);
+
+	if (cmd == MPLS_CMD_DELXC)
+		fprintf(fp, "deleted XC entry ");
+
+	if (cmd == MPLS_CMD_NEWXC)
+		fprintf(fp, "XC entry ");
+
+	fprintf(fp, "ilm_label ");
+	print_label(fp, &xc->mx_in);
+	fprintf(fp, "ilm_labelspace %d ", xc->mx_in.ml_index);
+	fprintf(fp, "nhlfe_key 0x%08x ",xc->mx_out.u.ml_key);
+	fprintf(fp, "\n");
+	fflush(fp);
+	return 0;
+}
+
+int print_labelspace(int cmd, const struct nlmsghdr *n, void *arg, struct rtattr **tb)
+{
+	FILE *fp = (FILE*)arg;
+	struct mpls_labelspace_req *ls;
+
+	ls = RTA_DATA(tb[MPLS_ATTR_LABELSPACE]);
+
+	fprintf(fp, "LABELSPACE entry ");
+
+	fprintf(fp, "dev %s ", ll_index_to_name(ls->mls_ifindex));
+	fprintf(fp, "labelspace %d ",ls->mls_labelspace);
+	fprintf(fp, "\n");
+	fflush(fp);
+
+	return 0;
+}
+
+int print_nhlfe(int cmd, const struct nlmsghdr *n, void *arg, struct rtattr **tb)
+{
+	FILE *fp = (FILE*)arg;
+	struct mpls_out_label_req *mol;
+	struct mpls_instr_req *instr;
+	struct gnet_stats_basic *stats;
+
+	mol = RTA_DATA(tb[MPLS_ATTR_NHLFE]);
+	instr = RTA_DATA(tb[MPLS_ATTR_INSTR]);
+	stats = RTA_DATA(tb[MPLS_ATTR_STATS]);
+
+	if (cmd == MPLS_CMD_DELNHLFE)
+		fprintf(fp, "deleted NHLFE entry ");
+
+	if (cmd == MPLS_CMD_NEWNHLFE)
+		fprintf(fp, "NHLFE entry ");
+
+	fprintf(fp, "key 0x%08x ", mol->mol_label.u.ml_key);
+	fprintf(fp, "mtu %d ",mol->mol_mtu);
+	if (mol->mol_propagate_ttl) {
+		fprintf(fp, "propagate_ttl ");
+	}
+	fprintf(fp, "\n\t");
+	if (instr && instr->mir_instr_length) {
+		print_instructions(fp, instr);
+	}
+
+	if (stats)
+		print_mpls_stats(fp, stats);
+	fprintf(fp, "\n");
+
+	fflush(fp);
+	return 0;
+}
+
+int print_tunnel(const struct mpls_tunnel_req *mtr, void *arg)
+{
+	FILE *fp = (FILE*)arg;
+
+	fprintf(fp, "%s 0x%08x", mtr->mt_ifname, mtr->mt_nhlfe_key);
+	fprintf(fp, "\n");
+
+	fflush(fp);
+	return 0;
+}
+
+int print_mpls(const struct sockaddr_nl *who, struct nlmsghdr *n, void *arg)
+{
+	struct rtattr *tb[MPLS_ATTR_MAX + 1];
+	struct genlmsghdr *ghdr = NLMSG_DATA(n);
+	int len = n->nlmsg_len;
+	struct rtattr *attrs;
+
+	if (n->nlmsg_type !=  PF_MPLS) {
+		fprintf(stderr, "Not a controller message, nlmsg_len=%d "
+			"nlmsg_type=0x%x\n", n->nlmsg_len, n->nlmsg_type);
+		return 0;
+	}
+
+        len -= NLMSG_LENGTH(GENL_HDRLEN);
+        if (len < 0) {
+                fprintf(stderr, "BUG: wrong nlmsg len %d\n", len);
+                return -1;
+        }
+
+	attrs = (struct rtattr *) ((char *) ghdr + GENL_HDRLEN);
+	parse_rtattr(tb, MPLS_ATTR_MAX, attrs, len);
+
+	switch (ghdr->cmd) {
+		case MPLS_CMD_NEWILM:
+			return print_ilm(ghdr->cmd, n,arg,tb);
+		case MPLS_CMD_NEWNHLFE:
+			return print_nhlfe(ghdr->cmd, n,arg,tb);
+		case MPLS_CMD_NEWXC:
+			return print_xc(ghdr->cmd, n,arg,tb);
+		case MPLS_CMD_SETLABELSPACE:
+			return print_labelspace(ghdr->cmd, n,arg,tb);
+		default:
+			return 0;
+	}
+
+#if 0
+	if (n->nlmsg_type >= MPLS_RTM_ADDTUNNEL &&
+		n->nlmsg_type <= MPLS_RTM_DELTUNNEL) {
+		return print_tunnel(n,arg, tb);
+	}
+#endif
+	return 0;
+}
+
+int mpls_list(int cmd,int argc, char **argv)
+{
+	struct genlmsghdr *ghdr;
+	struct rtnl_handle rth;
+
+	struct {
+		struct nlmsghdr		n;
+		char			buf[4096];
+	} req;
+
+	if (rtnl_open_byproto(&rth, 0, NETLINK_GENERIC) < 0) {
+		fprintf (stderr, "Error opening nl socket\n");
+		exit(-1);
+	}
+	memset(&req, 0, sizeof(req));
+
+	req.n.nlmsg_len = NLMSG_LENGTH(GENL_HDRLEN);
+	req.n.nlmsg_flags = NLM_F_ROOT|NLM_F_MATCH|NLM_F_REQUEST;
+	req.n.nlmsg_type = PF_MPLS;
+	req.n.nlmsg_seq = rth.dump = ++rth.seq;
+
+	ghdr = NLMSG_DATA(&req.n);
+	ghdr->cmd = cmd;
+	
+	if (rtnl_send(&rth, (const char *)&req.n, req.n.nlmsg_len) < 0) {
+		perror("Cannot send dump request");
+		exit(1);
+	}
+
+	if (rtnl_dump_filter(&rth, print_mpls, stdout, NULL, NULL) < 0) {
+		fprintf(stderr, "Dump terminated\n");
+		exit(1);
+	}
+	rtnl_close(&rth);
+
+	return 0;
+}
+
+int do_ilm(int argc, char **argv) {
+
+	if (argc <= 0 || matches(*argv, "list") == 0 ||
+		matches(*argv, "show") == 0)
+		return mpls_list(MPLS_CMD_GETILM,argc-1, argv+1);
+	if (matches(*argv, "add") == 0)
+		return mpls_ilm_modify(MPLS_CMD_NEWILM, NLM_F_CREATE,
+			argc-1, argv+1);
+	if (matches(*argv, "change") == 0)
+		return mpls_ilm_modify(MPLS_CMD_NEWILM, 0, argc-1, argv+1);
+	if (matches(*argv, "delete") == 0)
+		return mpls_ilm_modify(MPLS_CMD_DELILM, 0, argc-1, argv+1);
+	if (matches(*argv, "help") == 0)
+		usage();
+	else {
+		fprintf(stderr,
+		    "Option \"%s\" is unknown, try \"mpls -help\".\n", argv[0]);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int do_nhlfe(int argc, char **argv)
+{
+	if (argc <= 0 || matches(*argv, "list") == 0 ||
+	    matches(*argv, "show") == 0)
+		return mpls_list(MPLS_CMD_GETNHLFE,argc-1, argv+1);
+	if (matches(*argv, "add") == 0)
+		return mpls_nhlfe_modify(MPLS_CMD_NEWNHLFE,
+		    NLM_F_CREATE, argc-1, argv+1);
+	if (matches(*argv, "change") == 0)
+		return mpls_nhlfe_modify(MPLS_CMD_NEWNHLFE, 0, argc-1, argv+1);
+	if (matches(*argv, "delete") == 0)
+		return mpls_nhlfe_modify(MPLS_CMD_DELNHLFE, 0, argc-1, argv+1);
+	if (matches(*argv, "help") == 0)
+		usage();
+	else {
+		fprintf(stderr,
+		    "Option \"%s\" is unknown, try \"mpls -help\".\n", argv[0]);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int do_xc(int argc, char **argv) {
+
+	if (argc <= 0 || matches(*argv, "list") == 0 ||
+	    matches(*argv, "show") == 0)
+		return mpls_list(MPLS_CMD_GETXC,argc-1, argv+1);
+	if (matches(*argv, "add") == 0)
+		return mpls_xc_modify(MPLS_CMD_NEWXC, NLM_F_CREATE,
+			argc-1, argv+1);
+	if (matches(*argv, "delete") == 0)
+		return mpls_xc_modify(MPLS_CMD_DELXC, 0, argc-1, argv+1);
+	if (matches(*argv, "help") == 0)
+		usage();
+	else {
+		fprintf(stderr,
+		    "Option \"%s\" is unknown, try \"mpls -help\".\n", argv[0]);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int do_labelspace(int argc, char **argv) {
+
+	if (argc <= 0 || matches(*argv, "list") == 0 ||
+	    matches(*argv, "show") == 0)
+		return mpls_list(MPLS_CMD_GETLABELSPACE,argc-1, argv+1);
+	if (matches(*argv, "set") == 0)
+		return mpls_labelspace_modify(MPLS_CMD_SETLABELSPACE,
+			0, argc-1, argv+1);
+	if (matches(*argv, "help") == 0)
+		usage();
+	else {
+		fprintf(stderr,
+		    "Option \"%s\" is unknown, try \"mpls -help\".\n", argv[0]);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int do_tunnel(int argc, char **argv) {
+	if (argc <= 0)
+	    usage();
+	if (matches(*argv, "add") == 0)
+		return mpls_tunnel_modify(SIOCADDTUNNEL, argc-1, argv+1);
+	if (matches(*argv, "delete") == 0)
+		return mpls_tunnel_modify(SIOCDELTUNNEL, argc-1, argv+1);
+	if (matches(*argv, "set") == 0)
+		return mpls_tunnel_modify(SIOCCHGTUNNEL, argc-1, argv+1);
+	if (matches(*argv, "get") == 0)
+		return mpls_tunnel_modify(SIOCGETTUNNEL, argc-1, argv+1);
+	if (matches(*argv, "help") == 0)
+		usage();
+	else {
+		fprintf(stderr,
+		    "Option \"%s\" is unknown, try \"mpls -help\".\n", argv[0]);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int main(int argc, char **argv) {
+	char *basename;
+	int retval;
+
+	basename = strrchr(argv[0], '/');
+	if (basename == NULL)
+		basename = argv[0];
+	else
+		basename++;
+
+	while (argc > 1) {
+		if (argv[1][0] != '-')
+			break;
+		if (matches(argv[1], "-Version") == 0) {
+			printf("mpls utility, iproute2-ss%s mpls-linux %d.%d%d%d\n",
+				SNAPSHOT, (MPLS_LINUX_VERSION >> 24) & 0xFF,
+				(MPLS_LINUX_VERSION >> 16) & 0xFF,
+				(MPLS_LINUX_VERSION >> 8) & 0xFF,
+				(MPLS_LINUX_VERSION) & 0xFF);
+			exit(0);
+		} else if (matches(argv[1], "-help") == 0) {
+			usage();
+		} else {
+			fprintf(stderr, "Option \"%s\" is unknown, try \"mpls -help\".\n", argv[1]);
+			exit(-1);
+		}
+		argc--;	argv++;
+	}
+
+	if (argc > 1) {
+		if (rtnl_open(&rth1, 0) < 0) {
+			fprintf (stderr, "Error openning netlink socket\n");
+			exit(-1);
+		}
+		ll_init_map(&rth1);
+		rtnl_close(&rth1);
+
+		if (matches(argv[1], "monitor") == 0) {
+			retval = do_mplsmonitor(argc-2,argv+2);
+		} else {
+			if (rtnl_open_byproto(&rth1, MPLS_GRP_NHLFE,
+				NETLINK_GENERIC) < 0) {
+				fprintf (stderr,"Error opening NHLFE rtnl\n");
+				exit(-1);
+			}
+			if (rtnl_open_byproto(&rth2, 0, NETLINK_GENERIC) < 0) {
+				fprintf (stderr,"Error opening generic rtnl\n");
+				exit(-1);
+			}
+			if (matches(argv[1], "nhlfe") == 0) {
+				retval = do_nhlfe(argc-2,argv+2);
+			} else if (matches(argv[1], "ilm") == 0) {
+				retval = do_ilm(argc-2,argv+2);
+			} else if (matches(argv[1], "xc") == 0) {
+				retval = do_xc(argc-2,argv+2);
+			} else if (matches(argv[1], "labelspace") == 0) {
+				retval = do_labelspace(argc-2,argv+2);
+			} else if (matches(argv[1], "tunnel") == 0) {
+				retval = do_tunnel(argc-2,argv+2);
+			} else {
+				usage();
+				retval = 1;
+			}
+			rtnl_close(&rth1);
+			rtnl_close(&rth2);
+		}
+	} else {
+		usage();
+		retval = 1;
+	}
+	return retval;
+}
diff -Naur iproute2-2.6.22-070710/mpls/mpls.h iproute2-mpls-1.1/mpls/mpls.h
--- iproute2-2.6.22-070710/mpls/mpls.h	1970-01-01 01:00:00.000000000 +0100
+++ iproute2-mpls-1.1/mpls/mpls.h	2008-10-07 14:40:31.000000000 +0200
@@ -0,0 +1,11 @@
+#ifndef IPROUTE_MPLS_H
+#define IPROUTE_MPLS_H
+
+extern int print_ilm(struct sockaddr_nl *who, struct nlmsghdr *n, void *arg);
+extern int print_xc(struct sockaddr_nl *who, struct nlmsghdr *n, void *arg);
+extern int print_labelspace(struct sockaddr_nl *who, struct nlmsghdr *n,
+	void *arg);
+extern int print_nhlfe(struct sockaddr_nl *who, struct nlmsghdr *n, void *arg);
+
+#endif
+
diff -Naur iproute2-2.6.22-070710/mpls/mpls_monitor.c iproute2-mpls-1.1/mpls/mpls_monitor.c
--- iproute2-2.6.22-070710/mpls/mpls_monitor.c	1970-01-01 01:00:00.000000000 +0100
+++ iproute2-mpls-1.1/mpls/mpls_monitor.c	2008-10-07 14:40:31.000000000 +0200
@@ -0,0 +1,163 @@
+/*
+ * mplsmonitor.c	"mpls monitor".
+ *
+ *		This program is free software; you can redistribute it and/or
+ *		modify it under the terms of the GNU General Public License
+ *		as published by the Free Software Foundation; either version
+ *		2 of the License, or (at your option) any later version.
+ *
+ * Authors:	James R. Leu <jleu@mindspring.com> shamlesslessly copied
+ *		this code from Alexey Kuznetsov, <kuznet@ms2.inr.ac.ru>
+ *
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <string.h>
+#include <time.h>
+#include <linux/mpls.h>
+#include <linux/genetlink.h>
+
+#include "utils.h"
+
+extern int print_ilm(int cmd, const struct nlmsghdr *n, void *arg, struct rtattr **tb);
+extern int print_nhlfe(int cmd, const struct nlmsghdr *n, void *arg, struct rtattr **tb);
+extern int print_xc(int cmd, const struct nlmsghdr *n, void *arg, struct rtattr **tb);
+extern int print_labelspace(int cmd, const struct nlmsghdr *n, void *arg, struct rtattr **tb);
+
+static void usage(void) __attribute__((noreturn));
+
+static void usage(void)
+{
+	fprintf(stderr, "Usage: mpls monitor [ all | LISTofOBJECTS ]\n");
+	exit(-1);
+}
+
+int accept_msg(const struct sockaddr_nl *who, struct nlmsghdr *n, void *arg)
+{
+	FILE *fp = (FILE*)arg;
+        struct rtattr *tb[MPLS_ATTR_MAX + 1];
+        struct genlmsghdr *ghdr = NLMSG_DATA(n);
+        int len = n->nlmsg_len;
+        struct rtattr *attrs;
+
+        if (n->nlmsg_type !=  PF_MPLS) {
+                fprintf(stderr, "Not a controller message, nlmsg_len=%d "
+                        "nlmsg_type=0x%x\n", n->nlmsg_len, n->nlmsg_type);
+                return 0;
+        }
+
+        len -= NLMSG_LENGTH(GENL_HDRLEN);
+        if (len < 0) {
+                fprintf(stderr, "BUG: wrong nlmsg len %d\n", len);
+                return -1;
+        }
+
+        attrs = (struct rtattr *) ((char *) ghdr + GENL_HDRLEN);
+        parse_rtattr(tb, MPLS_ATTR_MAX, attrs, len);
+
+	switch (ghdr->cmd) {
+		case MPLS_CMD_NEWNHLFE:
+		case MPLS_CMD_DELNHLFE:
+			print_nhlfe(ghdr->cmd, n, arg, tb);
+			return 0;
+		case MPLS_CMD_NEWILM:
+		case MPLS_CMD_DELILM:
+			print_ilm(ghdr->cmd, n, arg, tb);
+			return 0;
+		case MPLS_CMD_NEWXC:
+		case MPLS_CMD_DELXC:
+			print_xc(ghdr->cmd, n, arg, tb);
+			return 0;
+		case MPLS_CMD_SETLABELSPACE:
+			print_labelspace(ghdr->cmd, n, arg, tb);
+			return 0;
+		default:
+			return -1;
+	}
+	if (n->nlmsg_type != NLMSG_ERROR && n->nlmsg_type != NLMSG_NOOP &&
+	    n->nlmsg_type != NLMSG_DONE) {
+		fprintf(fp, "Unknown message: %08x %08x %08x\n",
+			n->nlmsg_len, n->nlmsg_type, n->nlmsg_flags);
+	}
+	return 0;
+}
+
+int do_mplsmonitor(int argc, char **argv)
+{
+	struct rtnl_handle rth;
+	char *file = NULL;
+	unsigned int groups = 0xff;
+	int nhlfe=0;
+	int ilm=0;
+	int xc=0;
+	int labelspace=0;
+
+	while (argc > 0) {
+		if (matches(*argv, "file") == 0) {
+			NEXT_ARG();
+			file = *argv;
+		} else if (matches(*argv, "nhlfe") == 0) {
+			nhlfe=1;
+			groups = 0;
+		} else if (matches(*argv, "ilm") == 0) {
+			ilm=1;
+			groups = 0;
+		} else if (matches(*argv, "xc") == 0) {
+			xc=1;
+			groups = 0;
+		} else if (matches(*argv, "labelspace") == 0) {
+			labelspace=1;
+			groups = 0;
+		} else if (strcmp(*argv, "all") == 0) {
+			groups = 0xff;
+		} else if (matches(*argv, "help") == 0) {
+			usage();
+		} else {
+			fprintf(stderr, "Argument \"%s\" is unknown, try \"mpls monitor help\".\n", *argv);
+			exit(-1);
+		}
+		argc--;	argv++;
+	}
+
+	if (nhlfe)
+		groups |= MPLS_GRP_NHLFE;
+	if (ilm)
+		groups |= MPLS_GRP_ILM;
+	if (xc)
+		groups |= MPLS_GRP_XC;
+	if (labelspace)
+		groups |= MPLS_GRP_LABELSPACE;
+
+	if (file) {
+		FILE *fp;
+		fp = fopen(file, "r");
+		if (fp == NULL) {
+			perror("Cannot fopen");
+			exit(-1);
+		}
+		return rtnl_from_file(fp, accept_msg, (void*)stdout);
+	}
+
+	if (rtnl_open(&rth, 0) < 0) {
+		fprintf (stderr, "Error openning netlink socket\n");
+		exit(-1);
+	}
+	ll_init_map(&rth);
+	rtnl_close(&rth);
+
+	if (rtnl_open_byproto(&rth, groups, NETLINK_GENERIC) < 0)
+		exit(1);
+
+	if (rtnl_listen(&rth, accept_msg, (void*)stdout) < 0)
+		exit(2);
+
+	rtnl_close(&rth);
+	exit(0);
+}
diff -Naur iproute2-2.6.22-070710/tc/f_route.c iproute2-mpls-1.1/tc/f_route.c
--- iproute2-2.6.22-070710/tc/f_route.c	2007-07-11 03:34:14.000000000 +0200
+++ iproute2-mpls-1.1/tc/f_route.c	2008-10-07 14:40:31.000000000 +0200
@@ -80,6 +80,7 @@
 			fh &= 0xFFFF;
 			fh |= id<<16;
 		} else if (matches(*argv, "fromif") == 0) {
+			struct rtnl_handle rth;
 			__u32 id;
 			NEXT_ARG();
 			ll_init_map(&rth);
